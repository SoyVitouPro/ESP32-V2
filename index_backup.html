<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>LED Configuration</title>
    <style>
      :root {
        --bg: #0b0f14; --fg: #e7eef7; --muted: #93a1b1; --accent: #2aa198;
        --header-h: 56px;
      }
      * { box-sizing: border-box; }
      html, body { height: 100%; }
      body { margin: 0; background: var(--bg); color: var(--fg); font: 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; overflow: hidden; }
      header { height: var(--header-h); display:flex; align-items:center; justify-content:center; padding: 0 16px; text-align: center; background: #0f141a; position: sticky; top: 0; z-index: 20; }
      header h1 { margin: 0; font-size: 18px; }
      main { padding: 16px; max-width: 720px; margin: 0 auto; }
      .card { background: #121820; border: 1px solid #1f2a35; border-radius: 0; padding: 16px; }
      /* tabs removed */
      .row { display: grid; grid-template-columns: 140px 1fr; gap: 12px; align-items: center; margin: 10px 0; }
      .row label { color: var(--muted); }
      .muted { color: var(--muted); }
      .row input[type="text"], .row select, .row input[type="color"], .row input[type="range"] { width: 100%; padding: 10px 12px; border-radius: 10px; border: 1px solid #233040; background: #0e141b; color: var(--fg); }
      .row input[type="color"] { padding: 6px; height: 42px; }
      .inline { display:flex; gap:10px; align-items:center; }
      .btns { display: flex; gap: 12px; flex-wrap: wrap; margin-top: 12px; margin-bottom: 30px; }
      button { background: var(--accent); color: #093a39; border: 0; border-radius: 10px; padding: 10px 14px; font-weight: 600; cursor: pointer; }
      .icon-btn { background:#233040; color:var(--fg); border:0; border-radius:8px; padding:6px 10px; cursor:pointer; }
      .icon-btn:hover { background:#2d3b4d; }
      .tab { background:#233040; color: var(--fg); border:0; border-radius:8px; padding:8px 12px; cursor:pointer; }
      .tab.active { background: var(--accent); color:#093a39; }
      #previewBar { position: sticky; top: calc(var(--header-h) - 14px); z-index: 10; background: #0b0f14; padding: 4px 0; border-bottom: 1px solid #1f2a35; }
      #previewInner { display:flex; justify-content:center; }
      /* Keep panel row on a single line */
      #panelRow label, #panelRow input, #panelRow span { white-space: nowrap; display: inline-block; vertical-align: middle; }
      /* Thick blue separator between preview and configuration */
      #sepBar { height: 16px; background: #000000; border-radius: 8px; margin: 10px 0 12px; }
      canvas { width: 100%; max-width: 520px; border: 1px solid #243241; border-radius: 8px; background: #000; image-rendering: pixelated; }
      /* Thin custom scrollbar for the configuration scroll area */
      #configScroll { scrollbar-width: thin; scrollbar-color: #233040 #0e141b; }
      #configScroll::-webkit-scrollbar { width: 6px; }
      #configScroll::-webkit-scrollbar-track { background: #0e141b; }
      #configScroll::-webkit-scrollbar-thumb { background: #233040; border-radius: 3px; }
      /* Keep panel size inputs on one row even on mobile */
      #panelRow { grid-template-columns: 90px 1fr; column-gap: 4px; }
      #panelRow .inline { flex-wrap: nowrap; gap: 3px; }
      #panelRow select { width: 110px; min-width: 88px; }
      #panelRow select#pw { width: 90px; min-width: 72px; }
      footer { color: var(--muted); text-align: center; padding: 24px 0 40px; }
      @media (max-width: 640px) {
        .row { grid-template-columns: 1fr; }
        /* Override for panel row to keep label and fields in one line */
        #panelRow { grid-template-columns: 90px 1fr; column-gap: 4px; }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>LED Configuration</h1>
      <div class="actions" style="position:absolute; right:16px; display:flex; gap:8px;">
        <button id="btnPanelConfig" class="icon-btn" title="Panel Configuration" aria-label="Panel Configuration">⚙️</button>
      </div>
    </header>
    <main style="display:flex; flex-direction:column; height: calc(100vh - var(--header-h));">
      <div id="previewBar">
        <div id="previewInner">
          <canvas id="preview" width="256" height="96"></canvas>
        </div>
      </div>
      <div id="sepBar"></div>
      
      <div id="configScroll" style="flex:1 1 auto; overflow:auto;">
      <div class="card">
        <div class="row" id="modeTabs">
          <label>Mode</label>
          <div class="inline" style="gap:8px; flex-wrap:wrap;">
            <button id="tabText" class="tab active">Text</button>
            <button id="tabClock" class="tab">Clock</button>
            <button id="tabVideo" class="tab">Video</button>
          </div>
        </div>
        <div id="textConfig">
        <div class="row">
          <label for="text">Text</label>
          <input id="text" type="text" value="សួរស្ដីបង" />
        </div>
        <div class="row group-text">
          <label for="customFont">Font</label>
          <div class="inline" style="gap:8px; flex-wrap:wrap;">
            <input id="customFont" type="file" accept=".woff2,.woff,.ttf,.otf" />
            <span class="muted">Uses default Khmer fonts if none uploaded</span>
          </div>
        </div>
        <div class="row group-text" id="fontSourceRow">
          <label>Font Source</label>
          <div class="inline" style="gap:12px; flex-wrap:wrap;">
            <label class="muted" for="fontDefault" style="display:inline-flex; align-items:center; gap:6px;">
              <input type="radio" name="fontSource" id="fontDefault" value="default" checked /> Default
            </label>
            <label class="muted" for="fontUploaded" style="display:inline-flex; align-items:center; gap:6px;">
              <input type="radio" name="fontSource" id="fontUploaded" value="uploaded" disabled /> Uploaded
            </label>
          </div>
        </div>
        <div class="row group-text" id="fontSizeRow" style="margin-top: 17px;">
          <label for="fontSize">Font Size</label>
          <div class="inline" id="fontSizeInline">
            <input id="fontSize" type="range" min="10" max="50" value="30" />
            <span id="fontSizeVal">30 px</span>
          </div>
        </div>
        <div class="row" id="panelRow">
          <label for="pw">Panel:</label>
          <div class="inline" style="gap:8px; flex-wrap:nowrap;">
            <select id="pw">
              <option value="64">64</option>
              <option value="128" selected>128</option>
              <option value="192">192</option>
              <option value="256">256</option>
            </select>
            <span>×</span>
            <select id="ph">
              <option value="64" selected>64</option>
              <option value="128">128</option>
              <option value="192">192</option>
              <option value="256">256</option>
            </select>
          </div>
        </div>
        <div class="row group-text">
          <label for="color">Text Color</label>
          <input id="color" type="color" value="#ffffff" />
        </div>
        <div class="row">
          <label for="brightness">Brightness</label>
          <div class="inline">
            <input id="brightness" type="range" min="0" max="100" value="80" />
            <span id="brightnessVal">80%</span>
          </div>
        </div>
        <div class="row">
          <div style="grid-column: 1 / span 2; display:flex; align-items:center; gap:10px;">
            <label for="textBg" style="margin:0;">Text Background</label>
            <input id="textBg" type="checkbox" />
          </div>
        </div>
        <div class="row">
          <label></label>
          <div class="inline">
            <span class="muted">Color</span>
            <span class="muted" style="margin-left:16px">Padding</span>
            <span class="muted" style="margin-left:16px">Rounded</span>
            <span class="muted" style="margin-left:16px">Radius</span>
          </div>
        </div>
        <div class="row">
          <label></label>
          <div class="inline">
            <input id="textBgColor" type="color" value="#000000" />
            <select id="textBgPad">
              <option value="0">0 px</option>
              <option value="2" selected>2 px</option>
              <option value="4">4 px</option>
              <option value="6">6 px</option>
              <option value="8">8 px</option>
              <option value="10">10 px</option>
            </select>
            <input id="textBgRound" type="checkbox" />
            <select id="textBgRadius">
              <option value="0">0 px</option>
              <option value="4">4 px</option>
              <option value="6" selected>6 px</option>
              <option value="8">8 px</option>
              <option value="10">10 px</option>
              <option value="12">12 px</option>
              <option value="16">16 px</option>
              <option value="20">20 px</option>
            </select>
          </div>
        </div>
        <div class="row">
          <label for="bgMode">Background</label>
          <div class="inline">
            <select id="bgMode">
              <option value="color">Color</option>
              <option value="image">Image</option>
            </select>
            <input id="bg" type="color" value="#000000" />
            <input id="imageFile" type="file" accept="image/*" style="display:none" />
          </div>
        </div>
        <div class="row" id="imageFitRow" style="display:none;">
          <label></label>
          <div class="inline">
            <select id="imageFit">
              <option value="fill">Fill Panel</option>
              <option value="fit">Fit Inside</option>
              <option value="original">Original Size</option>
            </select>
          </div>
        </div>
        <div class="row">
          <label for="offx">Shift X</label>
          <div class="inline">
            <input id="offx" type="range" min="-256" max="256" value="0" />
            <span id="offxVal">0</span>
          </div>
        </div>
        <div class="row">
          <label for="offy">Shift Y</label>
          <div class="inline">
            <input id="offy" type="range" min="-128" max="128" value="0" />
            <span id="offyVal">0</span>
          </div>
        </div>
        <div class="row">
          <label for="animate">Translate Animation</label>
          <div class="inline">
            <input id="animate" type="checkbox" />
            <select id="dir">
              <option value="left">Shift Left</option>
              <option value="right">Shift Right</option>
            </select>
          </div>
        </div>
        <div class="row">
          <label for="speed">Speed</label>
          <div class="inline">
            <input id="speed" type="range" min="2" max="50" value="20" />
            <span id="speedVal">20 ms</span>
          </div>
        </div>
        <div class="row">
          <label for="interval">Loop Offset (px)</label>
          <div class="inline">
            <input id="interval" type="range" min="1" max="25" value="5" />
            <span id="intervalVal">5 px</span>
          </div>
        </div>
        <div class="btns">
          <button id="btn">Render & Upload</button>
          <button id="center">Center Text</button>
        </div>
        </div> <!-- end #textConfig -->
        <div id="clockConfig" style="display:none">
          <div class="row">
            <label for="clockFormat">Clock Format</label>
            <div class="inline">
              <select id="clockFormat">
                <option value="24" selected>24-hour</option>
                <option value="12">12-hour</option>
              </select>
            </div>
          </div>
          <div class="row">
            <label for="clockSize">Clock Size</label>
            <div class="inline">
              <input id="clockSize" type="range" min="10" max="50" value="28" />
              <span id="clockSizeVal">28 px</span>
            </div>
          </div>
          <div class="row">
            <label for="clockColor">Clock Color</label>
            <input id="clockColor" type="color" value="#ffffff" />
          </div>
          <div class="row">
            <label for="clockAuto">Auto Update</label>
            <div class="inline">
              <input id="clockAuto" type="checkbox" />
              <span class="muted">Interval</span>
              <select id="clockInterval">
                <option value="1">1s</option>
                <option value="5" selected>5s</option>
                <option value="10">10s</option>
                <option value="30">30s</option>
                <option value="60">60s</option>
              </select>
            </div>
          </div>
          <div class="btns">
            <button id="btnClock">Render Clock & Upload</button>
          </div>
        </div> <!-- end #clockConfig -->
        <div id="videoConfig" style="display:none">
          <div class="row">
            <label for="videoFile">Video</label>
            <div class="inline">
              <input id="videoFile" type="file" accept="video/*" />
            </div>
          </div>
          <div class="row" id="videoFitRow">
            <label for="videoFit">Fit</label>
            <div class="inline">
              <select id="videoFit">
                <option value="fill">Fill Panel</option>
                <option value="fit" selected>Fit Inside</option>
                <option value="original">Original Size</option>
              </select>
              <span class="muted">FPS</span>
              <select id="videoFps">
                <option value="5">5</option>
                <option value="10" selected>10</option>
                <option value="15">15</option>
                <option value="20">20</option>
              </select>
              <label class="muted" for="videoLoop" style="display:inline-flex; align-items:center; gap:6px;">
                <input id="videoLoop" type="checkbox" checked /> Loop
              </label>
            </div>
          </div>
          <div class="btns">
            <button id="btnVideoStart">Start Video Upload</button>
            <button id="btnVideoStop">Stop Video Upload</button>
          </div>
        </div> <!-- end #videoConfig -->
      </div>
      <footer></footer>
      </div>
      <!-- Panel Configuration Overlay -->
      <div id="panelConfigPage" style="display:none; position:fixed; left:0; right:0; top:var(--header-h); bottom:0; background: rgba(11,15,20,0.96); z-index:30;">
        <div style="max-width:820px; margin:16px auto; padding:16px; border:1px solid #1f2a35; background:#121820;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
            <h2 style="margin:0; font-size:16px; color:var(--fg);">Panel Configuration</h2>
            <button id="btnPanelClose" class="icon-btn">✖️</button>
          </div>
          <div class="row">
            <label for="panelRows">Rows × Cols</label>
            <div class="inline">
              <select id="panelRows">
                <option value="1">1</option>
                <option value="2" selected>2</option>
                <option value="3">3</option>
                <option value="4">4</option>
              </select>
              <span>×</span>
              <select id="panelCols">
                <option value="1">1</option>
                <option value="2" selected>2</option>
                <option value="3">3</option>
                <option value="4">4</option>
              </select>
              <span id="panelCount" class="muted">(4 panels)</span>
              <span id="panelDetected" class="muted" style="margin-left:12px;">(Detected: ...)</span>
            </div>
          </div>
          <div class="row">
            <label>Arrange</label>
            <div style="width:100%;">
              <div id="panelGrid" style="display:grid; grid-template-columns: repeat(2, 1fr); gap:8px;">
                <!-- cells injected -->
              </div>
            </div>
          </div>
          <div class="btns">
            <button id="btnPanelApply">Apply</button>
            <button id="btnPanelCancel" class="icon-btn">Cancel</button>
          </div>
        </div>
      </div>
    </main>
    <script>
      const c = document.getElementById('preview');
      const ctx = c.getContext('2d');
      const $ = id => document.getElementById(id);
      let loadedImg = null;
      let userFontLoaded = false;
      let clockPreviewTimer = 0;
      let videoEl = null;
      let videoPreviewRaf = 0;
      let videoUploadActive = false;
      let videoUploadLastMs = 0;
      let videoUploadIntervalMs = 100;
      let videoUploadInFlight = false;
      

      function rgb565(r,g,b){return ((r&0xF8)<<8)|((g&0xFC)<<3)|((b)>>3);} // 16-bit
      function cropImageData(img,w,h){
        let minX=w, minY=h, maxX=-1, maxY=-1;
        for(let y=0;y<h;y++){
          for(let x=0;x<w;x++){
            const a=img[(y*w+x)*4+3];
            if(a){ if(x<minX)minX=x; if(x>maxX)maxX=x; if(y<minY)minY=y; if(y>maxY)maxY=y; }
          }
        }
        if(maxX<minX||maxY<minY){return {x:0,y:0,w:0,h:0}};
        return {x:minX,y:minY,w:maxX-minX+1,h:maxY-minY+1};
      }

      // Preview animation state
      let rafId = 0; let lastTs = 0; let accMs = 0; let head0 = 0; let head1 = 0; let spacing = 0; let textW = 0; let textH = 0;

      function getFontFamily() {
        const useUploaded = (document.getElementById('fontUploaded') && document.getElementById('fontUploaded').checked);
        if (useUploaded && userFontLoaded) return `'UserFont', system-ui, Arial, sans-serif`;
        return `'Noto Sans Khmer', 'Khmer OS Content', system-ui, Arial, sans-serif`;
      }

      function initPreviewAnim() {
        const pw=parseInt($('pw').value,10); const ph=parseInt($('ph').value,10);
        const size=parseInt($('fontSize').value,10);
        const text=$('text').value;
        const fam = getFontFamily();
        const font = `bold ${size}px ${fam}`;
        // measure text width (approx, includes padding if enabled)
        ctx.font=font; ctx.textBaseline='middle'; ctx.textAlign='left';
        const m = ctx.measureText(text);
        const pad = $('textBg').checked ? (parseInt($('textBgPad').value,10) || 0) : 0;
        textW = Math.ceil(m.width) + pad*2;
        textH = Math.ceil(size*1.2) + pad*2;
        const gap = parseInt($('interval').value,10) || 1;
        spacing = Math.max(1, textW + gap);
        if ($('dir').value === 'left') {
          head0 = pw; head1 = head0 + spacing;
        } else {
          head0 = -textW; head1 = head0 - spacing;
        }
        lastTs = 0; accMs = 0;
      }

      function stopPreviewAnim() { if (rafId) { cancelAnimationFrame(rafId); rafId = 0; } }

      function drawPreviewFrame(animated){
        const text=$('text').value;
        const fam = getFontFamily();
        const size=parseInt($('fontSize').value,10);
        const font = `bold ${size}px ${fam}`;
        const color=$('color').value;
        const bg=$('bg').value;
        const pw=parseInt($('pw').value,10); const ph=parseInt($('ph').value,10);
        const offx=parseInt($('offx').value,10); const offy=parseInt($('offy').value,10);

        c.width = pw; c.height = ph; // always full panel preview
        ctx.clearRect(0,0,c.width,c.height);
        ctx.fillStyle=bg; ctx.fillRect(0,0,c.width,c.height);
        if ($('bgMode').value === 'image' && loadedImg) {
          const fit = $('imageFit').value;
          let dw = loadedImg.width, dh = loadedImg.height;
          if (fit === 'fill') { dw = pw; dh = ph; }
          else if (fit === 'fit') {
            const s = Math.min(pw/loadedImg.width, ph/loadedImg.height);
            dw = Math.max(1, Math.floor(loadedImg.width * s));
            dh = Math.max(1, Math.floor(loadedImg.height * s));
          } else if (fit === 'original') {
            dw = Math.min(pw, loadedImg.width); dh = Math.min(ph, loadedImg.height);
          }
          const dx = Math.floor(pw*0.5 - dw/2);
          const dy = Math.floor(ph*0.5 - dh/2);
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(loadedImg, dx, dy, dw, dh);
        }
        // text background box (optional) and text overlay
        const cy = Math.floor(ph*0.5) + offy;
        const pad = $('textBg').checked ? (parseInt($('textBgPad').value,10) || 0) : 0;
        ctx.font=font; ctx.textBaseline='middle'; ctx.fillStyle=color;
        if (animated && text.length > 0) {
          // draw two heads for seamless wrap
          ctx.textAlign='left';
          const drawAt = (leftX) => {
            const xLeft = Math.floor(leftX) + offx;
            if ($('textBg').checked){
              ctx.fillStyle = $('textBgColor').value;
              if ($('textBgRound').checked) {
                const r = parseInt($('textBgRadius').value,10) || 0;
                // rounded rect path
                const rr = Math.max(0, Math.min(r, Math.min(textW,textH)/2));
                ctx.beginPath();
                const rx = xLeft - pad, ry = cy - Math.floor(textH/2);
                const rw = textW, rh = textH;
                ctx.moveTo(rx+rr, ry);
                ctx.arcTo(rx+rw, ry,   rx+rw, ry+rh, rr);
                ctx.arcTo(rx+rw, ry+rh, rx,     ry+rh, rr);
                ctx.arcTo(rx,     ry+rh, rx,     ry,     rr);
                ctx.arcTo(rx,     ry,   rx+rw,   ry,     rr);
                ctx.closePath();
                ctx.fill();
              } else {
                ctx.fillRect(xLeft - pad, cy - Math.floor(textH/2), textW, textH);
              }
              ctx.fillStyle = color;
            }
            ctx.fillText(text, xLeft, cy);
          };
          drawAt(head0);
          drawAt(head1);
        } else {
          // static centered
          const cx = Math.floor(pw*0.5) + offx;
          ctx.textAlign='center';
          if ($('textBg').checked){
            const m = ctx.measureText(text);
            const tw = Math.ceil(m.width) + pad*2;
            const th = Math.ceil(size*1.2) + pad*2;
            ctx.fillStyle = $('textBgColor').value;
            if ($('textBgRound').checked) {
              const r = parseInt($('textBgRadius').value,10) || 0;
              const rr = Math.max(0, Math.min(r, Math.min(tw,th)/2));
              const rx = cx - Math.floor(tw/2), ry = cy - Math.floor(th/2);
              ctx.beginPath();
              ctx.moveTo(rx+rr, ry);
              ctx.arcTo(rx+tw, ry,   rx+tw, ry+th, rr);
              ctx.arcTo(rx+tw, ry+th, rx,    ry+th, rr);
              ctx.arcTo(rx,    ry+th, rx,    ry,    rr);
              ctx.arcTo(rx,    ry,   rx+tw,  ry,    rr);
              ctx.closePath();
              ctx.fill();
            } else {
              ctx.fillRect(cx - Math.floor(tw/2), cy - Math.floor(th/2), tw, th);
            }
            ctx.fillStyle = color;
          }
          ctx.fillText(text, cx, cy);
        }
      }

      function animatePreview(ts){
        if (!$('animate').checked || $('text').value.trim().length === 0) { stopPreviewAnim(); drawPreviewFrame(false); return; }
        if (!lastTs) lastTs = ts;
        const speed = parseInt($('speed').value,10) || 30; // ms/px
        accMs += (ts - lastTs); lastTs = ts;
        while (accMs >= speed) {
          accMs -= speed;
          if ($('dir').value === 'left') { head0 -= 1; head1 -= 1; }
          else { head0 += 1; head1 += 1; }
          const pw = parseInt($('pw').value,10);
          // recycle heads
          if ($('dir').value === 'left') {
            if (head0 + textW <= 0) head0 = head1 + spacing;
            if (head1 + textW <= 0) head1 = head0 + spacing;
          } else {
            if (head0 >= pw) head0 = head1 - spacing;
            if (head1 >= pw) head1 = head0 - spacing;
          }
        }
        drawPreviewFrame(true);
        rafId = requestAnimationFrame(animatePreview);
      }

      function drawPreview(){
        const clockMode = (document.getElementById('clockConfig') && document.getElementById('clockConfig').style.display !== 'none');
        const videoMode = (document.getElementById('videoConfig') && document.getElementById('videoConfig').style.display !== 'none');
        if (videoMode) {
          stopPreviewAnim(); drawVideoPreviewFrame();
        } else if (clockMode) {
          stopPreviewAnim(); drawClockPreviewFrame();
        } else if ($('animate').checked && $('text').value.trim().length > 0) {
          stopPreviewAnim(); initPreviewAnim(); drawPreviewFrame(true); rafId = requestAnimationFrame(animatePreview);
        } else {
          stopPreviewAnim(); drawPreviewFrame(false);
        }
      }

      // Attempt to load Khmer webfonts from device storage (LittleFS)
      // Place font files under data/fonts/ and uploadfs (e.g., NotoSansKhmer-Regular.woff2)
      async function loadKhmerWebFonts() {
        const candidates = [
          { family: 'Noto Sans Khmer', url: '/fonts/NotoSansKhmer-Regular.woff2' },
          { family: 'Khmer OS Content', url: '/fonts/KhmerOSContent.woff2' },
          { family: 'Hanuman', url: '/fonts/Hanuman-Regular.woff2' },
        ];
        for (const f of candidates) {
          try {
            const res = await fetch(f.url, { cache: 'no-store' });
            if (!res.ok) continue;
            const buf = await res.arrayBuffer();
            const face = new FontFace(f.family, buf);
            await face.load();
            document.fonts.add(face);
          } catch (_) { /* ignore missing fonts */ }
        }
        // Ensure canvas re-renders with any newly available fonts
        try { await document.fonts.ready; } catch(_){}
        drawPreview();
      }

      

      async function renderAndUpload(){
        drawPreview();
        const pw=parseInt($('pw').value,10); const ph=parseInt($('ph').value,10);
        const animate=$('animate').checked; const dir=$('dir').value;
        const speed=parseInt($('speed').value,10);
        const interval=parseInt($('interval').value,10);
        const offx=parseInt($('offx').value,10); const offy=parseInt($('offy').value,10);

        let outCanvas = document.createElement('canvas');
        if ($('bgMode').value === 'image' && loadedImg) {
          // Build panel-sized background image
          outCanvas.width = pw; outCanvas.height = ph;
          let octx = outCanvas.getContext('2d'); octx.imageSmoothingEnabled=false;
          const fit = $('imageFit').value;
          let dw = loadedImg.width, dh = loadedImg.height;
          if (fit === 'fill') { dw = pw; dh = ph; }
          else if (fit === 'fit') {
            const s = Math.min(pw/loadedImg.width, ph/loadedImg.height);
            dw = Math.max(1, Math.floor(loadedImg.width * s));
            dh = Math.max(1, Math.floor(loadedImg.height * s));
          } else { // original
            dw = Math.min(pw, loadedImg.width); dh = Math.min(ph, loadedImg.height);
          }
          const dx = Math.floor(pw*0.5 - dw/2);
          const dy = Math.floor(ph*0.5 - dh/2);
          // fill with bg color first (areas outside image)
          octx.fillStyle = $('bg').value; octx.fillRect(0,0,pw,ph);
          octx.drawImage(loadedImg, dx, dy, dw, dh);
          // Upload background first
          const outBg = octx.getImageData(0,0,pw,ph);
          const bufBg = new Uint8Array(4 + pw*ph*2);
          bufBg[0]=pw&255; bufBg[1]=(pw>>8)&255; bufBg[2]=ph&255; bufBg[3]=(ph>>8)&255;
          let pb=4; const db=outBg.data;
          for(let y=0;y<ph;y++){
            for(let x=0;x<pw;x++){
              const i=(y*pw+x)*4; const r=db[i], g=db[i+1], b=db[i+2];
              const v=rgb565(r,g,b);
              bufBg[pb++]=v&255; bufBg[pb++]=(v>>8)&255;
            }
          }
          const fdBg = new FormData();
          fdBg.append('image', new Blob([bufBg], {type:'application/octet-stream'}), 'bg.rgb565');
          await fetch('/upload_bg', { method:'POST', body: fdBg });
        }
        // Now build text-only transparent canvas (or skip if no text)
        if ($('text').value.trim().length > 0) {
          // Build transparent text-only canvas
          const fam = getFontFamily(); const size=parseInt($('fontSize').value,10);
          const font = `bold ${size}px ${fam}`;
          let t = document.createElement('canvas'); let tctx = t.getContext('2d');
          tctx.font=font; tctx.textBaseline='alphabetic'; tctx.textAlign='left';
          const metrics = tctx.measureText($('text').value);
          let tw = Math.max(1, Math.ceil(metrics.width)+4);
          let th = Math.max(1, Math.ceil(size*1.2 + 6));
          t.width = tw; t.height = th;
          tctx.font=font; tctx.textBaseline='alphabetic'; tctx.textAlign='left';
          // optional text background box (opaque)
          if ($('textBg').checked) {
            const pad = parseInt($('textBgPad').value,10) || 0;
            t.width = tw + pad*2; t.height = th + pad*2;
            // redraw font after resize
            tctx = t.getContext('2d'); tctx.font=font; tctx.textBaseline='alphabetic'; tctx.textAlign='left';
            tctx.fillStyle = $('textBgColor').value;
            if ($('textBgRound').checked) {
              const r = parseInt($('textBgRadius').value,10) || 0;
              const rr = Math.max(0, Math.min(r, Math.min(t.width,t.height)/2));
              tctx.beginPath();
              tctx.moveTo(rr, 0);
              tctx.arcTo(t.width, 0,   t.width, t.height, rr);
              tctx.arcTo(t.width, t.height, 0,   t.height, rr);
              tctx.arcTo(0,   t.height, 0,   0,   rr);
              tctx.arcTo(0,   0,   t.width, 0,   rr);
              tctx.closePath();
              tctx.fill();
            } else {
              tctx.fillRect(0, 0, t.width, t.height);
            }
          }
          tctx.fillStyle=$('color').value;
          const baseY = Math.floor(size);
          tctx.fillText($('text').value, 0, baseY);
          const img = tctx.getImageData(0,0,t.width,t.height);
          const bb = cropImageData(img.data, t.width, t.height);
          let outW = Math.max(1, bb.w), outH = Math.max(1, bb.h);
          outCanvas.width = outW; outCanvas.height = outH;
          outCanvas.getContext('2d').putImageData(new ImageData(img.data, t.width, t.height), -bb.x, -bb.y);
        } else {
          outCanvas.width = 1; outCanvas.height = 1; // minimal placeholder
        }

        // pack A8 + RGB565 (LE) per pixel with header [w,h]
        const out = outCanvas.getContext('2d').getImageData(0,0,outCanvas.width,outCanvas.height);
        const outW = outCanvas.width, outH = outCanvas.height;
        const buf = new Uint8Array(4 + outW*outH*3);
        buf[0]=outW&255; buf[1]=(outW>>8)&255; buf[2]=outH&255; buf[3]=(outH>>8)&255;
        let p=4; const d=out.data;
        for(let y=0;y<outH;y++){
          for(let x=0;x<outW;x++){
            const i=(y*outW+x)*4; const r=d[i], g=d[i+1], b=d[i+2], a=d[i+3];
            const v=rgb565(r,g,b);
            buf[p++]=a; buf[p++]=v&255; buf[p++]=(v>>8)&255;
          }
        }
        const fd = new FormData();
        fd.append('image', new Blob([buf], {type:'application/octet-stream'}), 'img.rgb565');
        fd.append('bg', $('bg').value);
        fd.append('bgMode', $('bgMode').value);
        fd.append('offx', offx);
        fd.append('offy', offy);
        fd.append('animate', ( $('text').value.trim().length>0 && animate)?1:0);
        fd.append('brightness', parseInt($('brightness').value, 10));
        fd.append('dir', dir);
        fd.append('speed', speed);
        fd.append('interval', interval);
        const res = await fetch('/upload', { method:'POST', body: fd });
        if(!res.ok){ alert('Upload failed: '+res.status); return; }
      }

      $('btn').addEventListener('click', renderAndUpload);
      // Tabs behavior
      (function initTabs(){
        const tabText = document.getElementById('tabText');
        const tabClock = document.getElementById('tabClock');
        const tabVideo = document.getElementById('tabVideo');
        const textCfg = document.getElementById('textConfig');
        const clockCfg = document.getElementById('clockConfig');
        const videoCfg = document.getElementById('videoConfig');
        function activate(which){
          if (which==='text'){
            tabText.classList.add('active'); tabClock.classList.remove('active'); if (tabVideo) tabVideo.classList.remove('active');
            textCfg.style.display='block'; clockCfg.style.display='none'; if (videoCfg) videoCfg.style.display='none';
            stopClockPreview(); stopVideoPreview();
          } else if (which==='clock') {
            tabClock.classList.add('active'); tabText.classList.remove('active'); if (tabVideo) tabVideo.classList.remove('active');
            clockCfg.style.display='block'; textCfg.style.display='none'; if (videoCfg) videoCfg.style.display='none';
            startClockPreview(); stopVideoPreview();
          } else if (which==='video') {
            if (tabVideo) tabVideo.classList.add('active'); tabText.classList.remove('active'); tabClock.classList.remove('active');
            if (videoCfg) videoCfg.style.display='block'; textCfg.style.display='none'; clockCfg.style.display='none';
            stopClockPreview(); startVideoPreview();
          }
          drawPreview();
        }
        if (tabText) tabText.addEventListener('click', ()=>activate('text'));
        if (tabClock) tabClock.addEventListener('click', ()=>activate('clock'));
        if (tabVideo) tabVideo.addEventListener('click', ()=>activate('video'));
      })();
      $('center').addEventListener('click', ()=>{ $('offx').value=0; $('offy').value=0; $('offxVal').textContent='0'; $('offyVal').textContent='0'; drawPreview(); });
      ['text','fontSize','color','bg','pw','ph','offx','offy','animate','dir','speed','interval','textBgRound','textBgRadius','brightness'].forEach(id=> $(id).addEventListener('input', ()=>{
        if(id==='fontSize'){ $('fontSizeVal').textContent = $('fontSize').value + ' px'; }
        if(id==='speed'){ $('speedVal').textContent = $('speed').value + ' ms'; }
        if(id==='interval'){ $('intervalVal').textContent = $('interval').value + ' px'; }
        if(id==='brightness'){ $('brightnessVal').textContent = $('brightness').value + '%'; }
        drawPreview();
      }));
      // Also update on change for selects (mobile-friendly)
      ['pw','ph'].forEach(id=> $(id).addEventListener('change', drawPreview));
      $('brightnessVal').textContent = $('brightness').value + '%';
      $('imageFile').addEventListener('change', (e)=>{
        const f = e.target.files && e.target.files[0];
        if(!f) return;
        const img = new Image();
        img.onload = ()=>{ loadedImg = img; drawPreview(); };
        const url = URL.createObjectURL(f);
        img.src = url;
      });

      // Panel configuration overlay logic
      let panelMap = [];
      let panelRows = 2, panelCols = 2;
      async function updatePanelDetected(){
        try{
          const r = await fetch('/panel_info');
          if (r.ok){ const j = await r.json(); const el = document.getElementById('panelDetected'); if (el) el.textContent = `(Detected: ${j.detected} panels)`; }
        }catch(_){ const el = document.getElementById('panelDetected'); if (el) el.textContent = '(Detected: n/a)'; }
      }

      function buildPanelGrid(){
        const grid = document.getElementById('panelGrid');
        if (!grid) return;
        grid.style.gridTemplateColumns = `repeat(${panelCols}, 1fr)`;
        grid.innerHTML='';
        const total = panelRows * panelCols;
        if (!panelMap || panelMap.length !== total) panelMap = Array.from({length: total}, (_,i)=>i);
        for (let i=0;i<total;i++){
          const cell = document.createElement('div');
          cell.textContent = (panelMap[i]+1);
          cell.setAttribute('draggable','true');
          cell.dataset.index = i;
          cell.style.cssText = 'background:#0e141b;border:1px solid #233040;padding:14px 0;text-align:center;user-select:none;';
          cell.addEventListener('dragstart', (ev)=>{ ev.dataTransfer.setData('text/plain', i.toString()); });
          cell.addEventListener('dragover', (ev)=>{ ev.preventDefault(); });
          cell.addEventListener('drop', (ev)=>{
            ev.preventDefault();
            const from = parseInt(ev.dataTransfer.getData('text/plain'));
            const to = parseInt(cell.dataset.index);
            const tmp = panelMap[from]; panelMap[from] = panelMap[to]; panelMap[to] = tmp;
            buildPanelGrid();
          });
          grid.appendChild(cell);
        }
        const countSpan = document.getElementById('panelCount');
        if (countSpan) countSpan.textContent = `(${total} panels)`;
      }
      async function openPanelConfig(){
        const page = document.getElementById('panelConfigPage');
        if (!page) return;
        // read selects
        const selR = document.getElementById('panelRows');
        const selC = document.getElementById('panelCols');
        if (selR) panelRows = parseInt(selR.value,10)||2;
        if (selC) panelCols = parseInt(selC.value,10)||2;
        buildPanelGrid();
        // push current selection to device so /panel_info reflects it
        try {
          const body = new URLSearchParams();
          body.set('rows', String(panelRows));
          body.set('cols', String(panelCols));
          body.set('map', '');
          await fetch('/panel_config', { method:'POST', body });
        } catch(_){}
        updatePanelDetected();
        page.style.display='block';
      }
      function closePanelConfig(){ const page = document.getElementById('panelConfigPage'); if (page) page.style.display='none'; }

      const btnPC = document.getElementById('btnPanelConfig');
      const btnPCClose = document.getElementById('btnPanelClose');
      const btnPCApply = document.getElementById('btnPanelApply');
      const btnPCCancel = document.getElementById('btnPanelCancel');
      if (btnPC) btnPC.addEventListener('click', openPanelConfig);
      if (btnPCClose) btnPCClose.addEventListener('click', closePanelConfig);
      if (btnPCCancel) btnPCCancel.addEventListener('click', closePanelConfig);
      const selRows = document.getElementById('panelRows');
      const selCols = document.getElementById('panelCols');
      if (selRows) selRows.addEventListener('change', ()=>{ panelRows = parseInt(selRows.value,10)||2; panelMap = []; buildPanelGrid(); });
      if (selCols) selCols.addEventListener('change', ()=>{ panelCols = parseInt(selCols.value,10)||2; panelMap = []; buildPanelGrid(); });
      if (btnPCApply) btnPCApply.addEventListener('click', async ()=>{
        // send panelMap/panelRows/panelCols to device (placeholder)
        const body = new URLSearchParams();
        body.set('rows', String(panelRows));
        body.set('cols', String(panelCols));
        body.set('map', panelMap.join(','));
        try { await fetch('/panel_config', { method:'POST', body }); } catch(_){ }
        closePanelConfig();
      });

      // Video preview helpers
      function drawVideoPreviewFrame(){
        if (!videoEl) return;
        const pw=parseInt($('pw').value,10); const ph=parseInt($('ph').value,10);
        const bg = $('bg').value;
        c.width = pw; c.height = ph;
        ctx.clearRect(0,0,c.width,c.height);
        ctx.fillStyle = bg; ctx.fillRect(0,0,pw,ph);
        // draw video frame with fit
        const fit = document.getElementById('videoFit') ? document.getElementById('videoFit').value : 'fit';
        let dw = videoEl.videoWidth || pw, dh = videoEl.videoHeight || ph;
        if (fit === 'fill') { dw = pw; dh = ph; }
        else if (fit === 'fit') {
          const s = Math.min(pw/(dw||1), ph/(dh||1)); dw = Math.max(1, Math.floor(dw*s)); dh = Math.max(1, Math.floor(dh*s));
        } else { // original
          dw = Math.min(pw, dw); dh = Math.min(ph, dh);
        }
        const dx = Math.floor(pw*0.5 - dw/2);
        const dy = Math.floor(ph*0.5 - dh/2);
        try { ctx.drawImage(videoEl, dx, dy, dw, dh); } catch(_){}
      }
      function videoPreviewLoop(ts){
        drawVideoPreviewFrame();
        // streaming upload synced with preview FPS
        if (videoUploadActive && !videoUploadInFlight) {
          if (!videoUploadLastMs) videoUploadLastMs = ts || performance.now();
          const now = ts || performance.now();
          if (now - videoUploadLastMs >= videoUploadIntervalMs) {
            videoUploadLastMs = now;
            // fire and forget upload of current frame
            uploadVideoFrame(true);
          }
        }
        videoPreviewRaf = requestAnimationFrame(videoPreviewLoop);
      }
      function startVideoPreview(){
        if (!videoEl || videoEl.readyState < 2) return; // not enough data
        if (videoPreviewRaf) cancelAnimationFrame(videoPreviewRaf);
        videoPreviewRaf = requestAnimationFrame(videoPreviewLoop);
      }
      function stopVideoPreview(){ if (videoPreviewRaf) { cancelAnimationFrame(videoPreviewRaf); videoPreviewRaf=0; } }

      // Video file load
      (function initVideo(){
        const vf = document.getElementById('videoFile');
        if (!vf) return;
        videoEl = document.createElement('video');
        videoEl.muted = true; videoEl.loop = true; videoEl.playsInline = true; videoEl.crossOrigin='anonymous';
        vf.addEventListener('change', async (e)=>{
          const f = e.target.files && e.target.files[0];
          if(!f) return;
          try {
            const url = URL.createObjectURL(f);
            videoEl.src = url;
            await videoEl.play();
            // if video tab active start preview
            const inVideo = (document.getElementById('videoConfig') && document.getElementById('videoConfig').style.display !== 'none');
            if (inVideo) startVideoPreview();
          } catch(err){ console.error('Video play failed', err); }
        });
      })();

      // Video upload
      async function uploadVideoFrame(nonBlocking){
        if (!videoEl) return;
        const pw=parseInt($('pw').value,10); const ph=parseInt($('ph').value,10);
        const t = document.createElement('canvas'); t.width = pw; t.height = ph; const tctx=t.getContext('2d');
        // background
        const bg = $('bg').value; tctx.fillStyle=bg; tctx.fillRect(0,0,pw,ph);
        // draw current video frame same as preview
        const fit = document.getElementById('videoFit') ? document.getElementById('videoFit').value : 'fit';
        let dw = videoEl.videoWidth || pw, dh = videoEl.videoHeight || ph;
        if (fit === 'fill') { dw = pw; dh = ph; }
        else if (fit === 'fit') {
          const s = Math.min(pw/(dw||1), ph/(dh||1)); dw = Math.max(1, Math.floor(dw*s)); dh = Math.max(1, Math.floor(dh*s));
        } else { dw = Math.min(pw, dw); dh = Math.min(ph, dh); }
        const dx = Math.floor(pw*0.5 - dw/2);
        const dy = Math.floor(ph*0.5 - dh/2);
        try { tctx.drawImage(videoEl, dx, dy, dw, dh); } catch(_){ return; }
        const out = tctx.getImageData(0,0,pw,ph);
        const buf = new Uint8Array(4 + pw*ph*2);
        buf[0]=pw&255; buf[1]=(pw>>8)&255; buf[2]=ph&255; buf[3]=(ph>>8)&255;
        let p=4; const d=out.data;
        for(let y=0;y<ph;y++){
          for(let x=0;x<pw;x++){
            const i=(y*pw+x)*4; const r=d[i], g=d[i+1], b=d[i+2];
            const v=((r&0xF8)<<8)|((g&0xFC)<<3)|((b)>>3);
            buf[p++]=v&255; buf[p++]=(v>>8)&255;
          }
        }
        const fd = new FormData();
        fd.append('image', new Blob([buf], {type:'application/octet-stream'}), 'video.rgb565');
        fd.append('bg', bg);
        fd.append('bgMode', 'color');
        fd.append('offx', 0);
        fd.append('offy', 0);
        fd.append('animate', 0);
        fd.append('dir', 'left');
        fd.append('speed', 20);
        fd.append('interval', 5);
        try {
          if (nonBlocking) {
            videoUploadInFlight = true;
            fetch('/upload', { method:'POST', body: fd }).finally(()=>{ videoUploadInFlight = false; });
          } else {
            await fetch('/upload', { method:'POST', body: fd });
          }
        } catch(_){ videoUploadInFlight = false; }
      }
      const btnVideoStart = document.getElementById('btnVideoStart');
      const btnVideoStop = document.getElementById('btnVideoStop');
      if (btnVideoStart) btnVideoStart.addEventListener('click', ()=>{
        const fpsSel = document.getElementById('videoFps');
        const fps = fpsSel ? parseInt(fpsSel.value,10) || 10 : 10;
        videoUploadIntervalMs = Math.max(50, Math.floor(1000/fps));
        videoUploadActive = true; videoUploadLastMs = 0;
        // ensure preview is running
        startVideoPreview();
      });
      if (btnVideoStop) btnVideoStop.addEventListener('click', ()=>{ videoUploadActive = false; videoUploadInFlight=false; });
      // tie loop checkbox to video element
      const loopCb = document.getElementById('videoLoop');
      if (loopCb) loopCb.addEventListener('change', ()=>{ if (videoEl) videoEl.loop = loopCb.checked; });
      // Clock preview: draw current time in the preview canvas
      function formatTime(fmt){
        const d = new Date();
        let h = d.getHours(); let m = d.getMinutes(); let s = d.getSeconds();
        if (fmt==='12') { const ampm = h>=12?'PM':'AM'; h = h%12 || 12; return `${(''+h).padStart(2,'0')}:${(''+m).padStart(2,'0')}:${(''+s).padStart(2,'0')} ${ampm}`; }
        return `${(''+h).padStart(2,'0')}:${(''+m).padStart(2,'0')}:${(''+s).padStart(2,'0')}`;
      }
      function drawClockPreviewFrame(){
        const pw=parseInt($('pw').value,10); const ph=parseInt($('ph').value,10);
        const offx=parseInt($('offx').value,10); const offy=parseInt($('offy').value,10);
        const fmt = $('clockFormat').value;
        const size = parseInt($('clockSize').value,10);
        const fam = getFontFamily(); const font = `bold ${size}px ${fam}`;
        const col = $('clockColor').value;
        const bg = $('bg').value;
        c.width = pw; c.height = ph;
        ctx.clearRect(0,0,c.width,c.height);
        // draw background (respect image mode)
        ctx.fillStyle = bg; ctx.fillRect(0,0,pw,ph);
        if ($('bgMode').value === 'image' && loadedImg) {
          const fit = $('imageFit').value;
          let dw = loadedImg.width, dh = loadedImg.height;
          if (fit === 'fill') { dw = pw; dh = ph; }
          else if (fit === 'fit') {
            const s = Math.min(pw/loadedImg.width, ph/loadedImg.height);
            dw = Math.max(1, Math.floor(loadedImg.width * s));
            dh = Math.max(1, Math.floor(loadedImg.height * s));
          } else if (fit === 'original') {
            dw = Math.min(pw, loadedImg.width); dh = Math.min(ph, loadedImg.height);
          }
          const dx = Math.floor(pw*0.5 - dw/2);
          const dy = Math.floor(ph*0.5 - dh/2);
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(loadedImg, dx, dy, dw, dh);
        }
        // draw time centered
        ctx.font = font; ctx.textBaseline='middle'; ctx.textAlign='center'; ctx.fillStyle=col;
        const txt = formatTime(fmt);
        ctx.fillText(txt, Math.floor(pw*0.5)+offx, Math.floor(ph*0.5)+offy);
      }
      function startClockPreview(){ if (clockPreviewTimer) clearInterval(clockPreviewTimer); drawClockPreviewFrame(); clockPreviewTimer = setInterval(drawClockPreviewFrame, 1000); }
      function stopClockPreview(){ if (clockPreviewTimer) { clearInterval(clockPreviewTimer); clockPreviewTimer=0; } }
      // Clock upload & auto update
      function formatTime(fmt){
        const d = new Date();
        let h = d.getHours(); let m = d.getMinutes(); let s = d.getSeconds();
        if (fmt==='12') { const ampm = h>=12?'PM':'AM'; h = h%12 || 12; return `${(''+h).padStart(2,'0')}:${(''+m).padStart(2,'0')}:${(''+s).padStart(2,'0')} ${ampm}`; }
        return `${(''+h).padStart(2,'0')}:${(''+m).padStart(2,'0')}:${(''+s).padStart(2,'0')}`;
      }
      async function renderAndUploadClock(){
        const pw=parseInt($('pw').value,10); const ph=parseInt($('ph').value,10);
        const offx=parseInt($('offx').value,10); const offy=parseInt($('offy').value,10);
        const fmt = $('clockFormat').value;
        const size = parseInt($('clockSize').value,10);
        const fam = getFontFamily(); const font = `bold ${size}px ${fam}`;
        const col = $('clockColor').value;
        const bg = $('bg').value;
        const t = document.createElement('canvas'); t.width = pw; t.height = ph; const tctx=t.getContext('2d');
        tctx.fillStyle=bg; tctx.fillRect(0,0,pw,ph);
        tctx.font=font; tctx.textBaseline='middle'; tctx.textAlign='center'; tctx.fillStyle=col;
        const txt = formatTime(fmt);
        tctx.fillText(txt, Math.floor(pw*0.5)+offx, Math.floor(ph*0.5)+offy);
        const out = tctx.getImageData(0,0,pw,ph);
        const buf = new Uint8Array(4 + pw*ph*2);
        buf[0]=pw&255; buf[1]=(pw>>8)&255; buf[2]=ph&255; buf[3]=(ph>>8)&255;
        let p=4; const d=out.data;
        for(let y=0;y<ph;y++){
          for(let x=0;x<pw;x++){
            const i=(y*pw+x)*4; const r=d[i], g=d[i+1], b=d[i+2];
            const v=((r&0xF8)<<8)|((g&0xFC)<<3)|((b)>>3);
            buf[p++]=v&255; buf[p++]=(v>>8)&255;
          }
        }
        const fd = new FormData();
        fd.append('image', new Blob([buf], {type:'application/octet-stream'}), 'clock.rgb565');
        fd.append('bg', bg);
        fd.append('bgMode', 'color');
        fd.append('offx', 0);
        fd.append('offy', 0);
        fd.append('animate', 0);
        fd.append('dir', 'left');
        fd.append('speed', 20);
        fd.append('interval', 5);
        await fetch('/upload', { method:'POST', body: fd });
      }
      let clockTimer = 0;
      const btnClock = document.getElementById('btnClock');
      if (btnClock) btnClock.addEventListener('click', async ()=>{
        await renderAndUploadClock();
        if ($('clockAuto').checked){
          if (clockTimer) clearInterval(clockTimer);
          const sec = parseInt($('clockInterval').value,10)||5;
          clockTimer = setInterval(renderAndUploadClock, sec*1000);
        } else {
          if (clockTimer) { clearInterval(clockTimer); clockTimer=0; }
        }
      });
      $('imageFit').addEventListener('change', drawPreview);
      $('bgMode').addEventListener('change', ()=>{
        const mode = $('bgMode').value;
        const showImg = mode==='image';
        $('bg').style.display = showImg? 'none':'inline-block';
        $('imageFile').style.display = showImg? 'inline-block':'none';
        const fitRow = document.getElementById('imageFitRow');
        if (fitRow) fitRow.style.display = showImg? 'grid':'none';
        drawPreview();
      });
      // initialize fit row on load
      (function(){ const showImg = $('bgMode').value==='image'; const fitRow = document.getElementById('imageFitRow'); if (fitRow) fitRow.style.display = showImg? 'grid':'none'; })();
      $('textBg').addEventListener('change', drawPreview);
      $('textBgColor').addEventListener('input', drawPreview);
      $('textBgPad').addEventListener('change', drawPreview);
      $('textBgRound').addEventListener('change', drawPreview);
      $('textBgRadius').addEventListener('change', drawPreview);
      $('fontSizeVal').textContent = $('fontSize').value + ' px';
      $('speedVal').textContent = $('speed').value + ' ms';
      $('intervalVal').textContent = $('interval').value + ' px';
      $('offx').addEventListener('input', ()=> $('offxVal').textContent=$('offx').value);
      $('offy').addEventListener('input', ()=> $('offyVal').textContent=$('offy').value);
      $('offxVal').textContent = $('offx').value;
      $('offyVal').textContent = $('offy').value;
      drawPreview();
      // Optional: Try loading local Khmer fonts if present on device (safe if 404)
      // loadKhmerWebFonts();

      // Allow user to upload a font (no internet needed)
      document.getElementById('customFont').addEventListener('change', async (e)=>{
        const f = e.target.files && e.target.files[0];
        if (!f) return;
        try {
          const data = await f.arrayBuffer();
          const ff = new FontFace('UserFont', data);
          await ff.load();
          document.fonts.add(ff);
          userFontLoaded = true;
          await document.fonts.ready;
          // enable the Uploaded radio and select it by default
          const uploadedRadio = document.getElementById('fontUploaded');
          if (uploadedRadio) { uploadedRadio.disabled = false; uploadedRadio.checked = true; }
          drawPreview();
        } catch (err) {
          console.error('Custom font failed to load', err);
          alert('Custom font failed to load');
        }
      });
      // Re-render when switching font source
      const fontDefault = document.getElementById('fontDefault');
      const fontUploaded = document.getElementById('fontUploaded');
      if (fontDefault) fontDefault.addEventListener('change', drawPreview);
      if (fontUploaded) fontUploaded.addEventListener('change', drawPreview);
    </script>
  </body>
  </html>
