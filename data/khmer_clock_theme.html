<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Khmer Clock Theme</title>
  </head>
  <body>
    <!-- FPS hint read by the uploader UI (1–30). -->
    <fps>1</fps>

    <!--
      Enhanced Khmer Clock Theme
      Supports multiple languages including Khmer, with configurable styles
      - Do NOT query the DOM or call getContext() here. The host page provides
        a 2D canvas context to themeRender(ctx, w, h, state, t).
      - Define themeInit() to return your state/config object.
      - Define themeRender() to draw a frame using the provided ctx.
    -->
    <script>
      function themeInit() {
        return {
          // Language settings
          language: 'khmer',              // 'khmer', 'english', 'both'
          format: '12',                   // '24' or '12'
          showSeconds: true,              // show or hide seconds
          showDate: false,                // show date below time

          // Style settings
          color: '#ffffff',               // text color
          bg: '#000000',                  // background color
          fontFamily: 'Khmer OS Content, Noto Sans Khmer, system-ui, Arial, sans-serif',
          weight: 'bold',

          // Layout settings
          datePosition: 'below',          // 'below' or 'above'
          spacing: 10,                    // spacing between time and date

          // Animation
          fadeSeconds: false,             // fade seconds display
          pulseColon: false,              // animate colon

          // Custom messages
          customMessage: '',              // custom message to show instead of time
          messagePosition: 'center'       // 'center', 'top', 'bottom'
        };
      }

      function pad(n) { return (n < 10 ? '0' : '') + n; }

      // Khmer number conversion
      function toKhmerNumber(n) {
        const khmerDigits = ['០', '១', '២', '៣', '៤', '៥', '៦', '៧', '៨', '៩'];
        return n.toString().split('').map(d => khmerDigits[parseInt(d)] || d).join('');
      }

      // Khmer month names
      function getKhmerMonth(month) {
        const khmerMonths = ['មករា', 'កុម្ភៈ', 'មីនា', 'មេសា', 'ឧសភា', 'មិថុនា',
                           'កក្កដា', 'សីហា', 'កញ្ញា', 'តុលា', 'វិច្ឆិកា', 'ធ្នូ'];
        return khmerMonths[month];
      }

      function formatTime(state, d) {
        let h = d.getHours();
        let m = d.getMinutes();
        let s = d.getSeconds();
        let suffix = '';

        if (state.format === '12') {
          suffix = (h < 12) ? ' AM' : ' PM';
          h = h % 12;
          if (h === 0) h = 12;
        }

        let timeStr = '';
        if (state.language === 'khmer') {
          // Khmer numbers
          timeStr = toKhmerNumber(h) + ':' + toKhmerNumber(m);
          if (state.showSeconds) {
            timeStr += ':' + toKhmerNumber(s);
          }
        } else if (state.language === 'english') {
          // English numbers
          timeStr = pad(h) + ':' + pad(m);
          if (state.showSeconds) {
            timeStr += ':' + pad(s);
          }
        } else { // both languages
          timeStr = toKhmerNumber(h) + ':' + toKhmerNumber(m);
          if (state.showSeconds) {
            timeStr += ':' + toKhmerNumber(s);
          }
          timeStr += ' / ' + pad(h) + ':' + pad(m);
          if (state.showSeconds) {
            timeStr += ':' + pad(s);
          }
        }

        return timeStr + suffix;
      }

      function formatDate(state, d) {
        if (state.language === 'khmer') {
          const day = toKhmerNumber(d.getDate());
          const month = getKhmerMonth(d.getMonth());
          const year = toKhmerNumber(d.getFullYear());
          return `${day} ${month} ${year}`;
        } else if (state.language === 'english') {
          return d.toLocaleDateString('en-US', {
            month: 'short',
            day: 'numeric',
            year: 'numeric'
          });
        } else { // both languages
          const day = toKhmerNumber(d.getDate());
          const month = getKhmerMonth(d.getMonth());
          const year = toKhmerNumber(d.getFullYear());
          const enDate = d.toLocaleDateString('en-US', {
            month: 'short',
            day: 'numeric',
            year: 'numeric'
          });
          return `${day} ${month} ${year} / ${enDate}`;
        }
      }

      // Fit font size that keeps text within canvas bounds
      function computeFontSize(ctx, w, h, text, family, weight, padding = 8) {
        let size = Math.max(8, Math.floor(h * 0.5));
        const maxWidth = w - (padding * 2);
        const maxHeight = h - (padding * 2);

        for (let i = 0; i < 20; i++) {
          ctx.font = `${weight} ${size}px ${family}`;
          const m = ctx.measureText(text);
          const textW = Math.ceil(m.width);
          const textH = Math.ceil(size * 1.1);

          if (textW <= maxWidth && textH <= maxHeight) break;
          size = Math.max(8, size - 2);
        }
        return size;
      }

      function themeRender(ctx, w, h, state, t) {
        // Clear background
        ctx.fillStyle = state.bg || '#000000';
        ctx.fillRect(0, 0, w, h);

        const now = new Date(t || Date.now());
        const family = state.fontFamily || 'system-ui, Arial, sans-serif';
        const weight = state.weight || 'bold';
        const color = state.color || '#ffffff';

        // Determine what to display
        let displayText = '';
        let isMessage = false;

        if (state.customMessage && state.customMessage.trim()) {
          displayText = state.customMessage;
          isMessage = true;
        } else {
          displayText = formatTime(state, now);
        }

        // Calculate layout
        let textY = Math.floor(h * 0.5);
        let textSize;

        if (state.showDate && !isMessage) {
          // Adjust for date display
          const dateText = formatDate(state, now);
          const timeSize = computeFontSize(ctx, w, h * 0.6, displayText, family, weight);
          const dateSize = Math.max(8, Math.floor(timeSize * 0.4));

          // Draw time
          ctx.font = `${weight} ${timeSize}px ${family}`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillStyle = color;

          if (state.datePosition === 'above') {
            textY = Math.floor(h * 0.6);
            ctx.fillText(displayText, Math.floor(w * 0.5), textY);

            // Draw date below
            ctx.font = `${weight} ${dateSize}px ${family}`;
            ctx.fillText(dateText, Math.floor(w * 0.5), Math.floor(h * 0.85));
          } else {
            textY = Math.floor(h * 0.4);
            ctx.fillText(displayText, Math.floor(w * 0.5), textY);

            // Draw date below
            ctx.font = `${weight} ${dateSize}px ${family}`;
            ctx.fillText(dateText, Math.floor(w * 0.5), Math.floor(h * 0.7));
          }
        } else {
          // Single text display (time or message)
          textSize = computeFontSize(ctx, w, h, displayText, family, weight);

          ctx.font = `${weight} ${textSize}px ${family}`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillStyle = color;

          if (state.messagePosition === 'top') {
            textY = Math.floor(h * 0.25);
          } else if (state.messagePosition === 'bottom') {
            textY = Math.floor(h * 0.75);
          } else {
            textY = Math.floor(h * 0.5);
          }

          ctx.fillText(displayText, Math.floor(w * 0.5), textY);
        }

        // Optional effects
        if (state.pulseColon && !isMessage && displayText.includes(':')) {
          // Animate colon
          const colonPositions = [];
          for (let i = 0; i < displayText.length; i++) {
            if (displayText[i] === ':') colonPositions.push(i);
          }

          ctx.font = `${weight} ${textSize}px ${family}`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';

          const m = ctx.measureText(displayText);
          const totalWidth = m.width;
          const startX = Math.floor(w * 0.5) - Math.floor(totalWidth * 0.5);

          colonPositions.forEach(pos => {
            const beforeText = displayText.substring(0, pos);
            const beforeM = ctx.measureText(beforeText);
            const colonX = startX + Math.floor(beforeM.width) + Math.floor(textSize * 0.2);

            // Pulsing effect
            const pulse = Math.sin((t || Date.now()) * 0.003) * 0.3 + 0.7;
            ctx.fillStyle = color + Math.floor(pulse * 255).toString(16).padStart(2, '0');
            ctx.fillText(':', colonX, textY);
          });
        }

        if (state.fadeSeconds && !isMessage && displayText.includes(':')) {
          // Fade seconds based on time
          const seconds = now.getSeconds();
          const fadeAlpha = 0.3 + (Math.sin(seconds * Math.PI / 30) * 0.7);

          // This would require redrawing with different alpha,
          // which is more complex and may not be worth the effort
          // for LED display purposes
        }
      }
    </script>
  </body>
</html>