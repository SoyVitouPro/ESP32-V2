<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" href="data:," />
    <title>LED Configuration</title>
    <style>
      :root {
        --bg: #0b0f14; --fg: #e7eef7; --muted: #93a1b1; --accent: #2aa198;
        --header-h: 56px;
      }
      * { box-sizing: border-box; }
      html, body { height: 100%; }
      body { margin: 0; background: var(--bg); color: var(--fg); font: 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; overflow: hidden; }
      header { height: var(--header-h); display:flex; align-items:center; justify-content:center; padding: 0 16px; text-align: center; background: #0f141a; position: sticky; top: 0; z-index: 20; }
      header h1 { margin: 0; font-size: 18px; }
      main { padding: 16px; max-width: 720px; margin: 0 auto; }
      .card { background: #121820; border: 1px solid #1f2a35; border-radius: 0; padding: 16px; }
      .row { display: grid; grid-template-columns: 140px 1fr; gap: 12px; align-items: center; margin: 10px 0; }
      .row label { color: var(--muted); }
      .muted { color: var(--muted); }
      .row input[type="text"], .row select, .row input[type="color"], .row input[type="range"] { width: 100%; padding: 10px 12px; border-radius: 10px; border: 1px solid #233040; background: #0e141b; color: var(--fg); }
      .row input[type="color"] { padding: 6px; height: 42px; }
      .inline { display:flex; gap:10px; align-items:center; }
      .btns { display: flex; gap: 12px; flex-wrap: wrap; margin-top: 12px; margin-bottom: 30px; }
      button { background: var(--accent); color: #093a39; border: 0; border-radius: 10px; padding: 10px 14px; font-weight: 600; cursor: pointer; }
      .icon-btn { background:#233040; color:var(--fg); border:0; border-radius:8px; padding:6px 10px; cursor:pointer; }
      .icon-btn:hover { background:#2d3b4d; }
      .tab { background:#233040; color: var(--fg); border:0; border-radius:8px; padding:8px 12px; cursor:pointer; }
      .tab.active { background: var(--accent); color:#093a39; }
      #previewBar { position: sticky; top: calc(var(--header-h) - 14px); z-index: 10; background: #0b0f14; padding: 4px 0; border-bottom: 1px solid #1f2a35; }
      #previewInner { display:flex; justify-content:center; }
      #panelRow label, #panelRow input, #panelRow span { white-space: nowrap; display: inline-block; vertical-align: middle; }
      #sepBar { height: 16px; background: #000000; border-radius: 8px; margin: 10px 0 12px; }
      canvas { width: 100%; max-width: 520px; border: 1px solid #243241; border-radius: 8px; background: #000; image-rendering: pixelated; }
      #configScroll { scrollbar-width: thin; scrollbar-color: #233040 #0e141b; }
      #configScroll::-webkit-scrollbar { width: 6px; }
      #configScroll::-webkit-scrollbar-track { background: #0e141b; }
      #configScroll::-webkit-scrollbar-thumb { background: #233040; border-radius: 3px; }
      #panelRow { grid-template-columns: 90px 1fr; column-gap: 4px; }
      #panelRow .inline { flex-wrap: nowrap; gap: 3px; }
      #panelRow select { width: 110px; min-width: 88px; }
      #panelRow select#pw { width: 90px; min-width: 72px; }
      footer { color: var(--muted); text-align: center; padding: 24px 0 40px; }
      @media (max-width: 640px) {
        .row { grid-template-columns: 1fr; }
        #panelRow { grid-template-columns: 90px 1fr; column-gap: 4px; }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>LED Configuration</h1>
      <div class="actions" style="position:absolute; right:16px; display:flex; gap:8px;">
        <button id="btnPanelConfig" class="icon-btn" title="Panel Configuration" aria-label="Panel Configuration">⚙️</button>
      </div>
    </header>
    <main style="display:flex; flex-direction:column; height: calc(100vh - var(--header-h));">
      <div id="previewBar">
        <div id="previewInner">
          <canvas id="preview" width="128" height="64"></canvas>
        </div>
      </div>
      <div id="sepBar"></div>

      <div id="configScroll" style="flex:1 1 auto; overflow:auto;">
      <div class="card">
        <div class="row" id="modeTabs">
          <label>Mode</label>
          <div class="inline" style="gap:8px; flex-wrap:wrap;">
            <button id="tabText" class="tab active">Text</button>
            <button id="tabClock" class="tab">Clock</button>
            <button id="tabVideo" class="tab">Video</button>
            <button id="tabTheme" class="tab">Theme</button>
          </div>
        </div>
        <div id="textConfig">
        <div class="row">
          <label for="text">Text</label>
          <input id="text" type="text" value="សួរស្ដីបង" />
        </div>
        <div class="row group-text">
          <label for="customFont">Font</label>
          <div class="inline" style="gap:8px; flex-wrap:wrap;">
            <input id="customFont" type="file" accept=".woff2,.woff,.ttf,.otf" />
            <span class="muted">Uses default Khmer fonts if none uploaded</span>
          </div>
        </div>
        <div class="row group-text" id="fontSourceRow">
          <label>Font Source</label>
          <div class="inline" style="gap:12px; flex-wrap:wrap;">
            <label class="muted" for="fontDefault" style="display:inline-flex; align-items:center; gap:6px;">
              <input type="radio" name="fontSource" id="fontDefault" value="default" checked /> Default
            </label>
            <label class="muted" for="fontUploaded" style="display:inline-flex; align-items:center; gap:6px;">
              <input type="radio" name="fontSource" id="fontUploaded" value="uploaded" disabled /> Uploaded
            </label>
          </div>
        </div>
        <div class="row group-text" id="fontSizeRow" style="margin-top: 17px;">
          <label for="fontSize">Font Size</label>
          <div class="inline" id="fontSizeInline">
            <input id="fontSize" type="range" min="10" max="50" value="30" />
            <span id="fontSizeVal">30 px</span>
          </div>
        </div>
        <div class="row" id="panelRow">
          <label for="pw">Panel:</label>
          <div class="inline" style="gap:8px; flex-wrap:nowrap;">
            <select id="pw">
              <option value="64">64</option>
              <option value="128" selected>128</option>
              <option value="192">192</option>
              <option value="256">256</option>
            </select>
            <span>×</span>
            <select id="ph">
              <option value="64" selected>64</option>
              <option value="128">128</option>
              <option value="192">192</option>
              <option value="256">256</option>
            </select>
          </div>
        </div>
        <div class="row group-text">
          <label for="color">Text Color</label>
          <input id="color" type="color" value="#ffffff" />
        </div>
        <div class="row">
          <label for="brightness">Brightness</label>
          <div class="inline">
            <input id="brightness" type="range" min="0" max="100" value="80" />
            <span id="brightnessVal">80%</span>
          </div>
        </div>
        <div class="row">
          <div style="grid-column: 1 / span 2; display:flex; align-items:center; gap:10px;">
            <label for="textBg" style="margin:0;">Text Background</label>
            <input id="textBg" type="checkbox" />
          </div>
        </div>
        <div class="row">
          <label></label>
          <div class="inline">
            <span class="muted">Color</span>
            <span class="muted" style="margin-left:16px">Padding</span>
            <span class="muted" style="margin-left:16px">Rounded</span>
            <span class="muted" style="margin-left:16px">Radius</span>
          </div>
        </div>
        <div class="row">
          <label></label>
          <div class="inline">
            <input id="textBgColor" type="color" value="#000000" />
            <select id="textBgPad">
              <option value="0">0 px</option>
              <option value="2" selected>2 px</option>
              <option value="4">4 px</option>
              <option value="6">6 px</option>
              <option value="8">8 px</option>
              <option value="10">10 px</option>
            </select>
            <input id="textBgRound" type="checkbox" />
            <select id="textBgRadius">
              <option value="0">0 px</option>
              <option value="4">4 px</option>
              <option value="6" selected>6 px</option>
              <option value="8">8 px</option>
              <option value="10">10 px</option>
              <option value="12">12 px</option>
              <option value="16">16 px</option>
              <option value="20">20 px</option>
            </select>
          </div>
        </div>
        <div class="row">
          <label for="bgMode">Background</label>
          <div class="inline">
            <select id="bgMode">
              <option value="color">Color</option>
              <option value="image">Image</option>
            </select>
            <input id="bg" type="color" value="#000000" />
            <input id="imageFile" type="file" accept="image/*" style="display:none" />
          </div>
        </div>
        <div class="row" id="imageFitRow" style="display:none;">
          <label></label>
          <div class="inline">
            <select id="imageFit">
              <option value="fill">Fill Panel</option>
              <option value="fit">Fit Inside</option>
              <option value="original">Original Size</option>
            </select>
          </div>
        </div>
        <div class="row">
          <label for="offx">Shift X</label>
          <div class="inline">
            <input id="offx" type="range" min="-256" max="256" value="0" />
            <span id="offxVal">0</span>
          </div>
        </div>
        <div class="row">
          <label for="offy">Shift Y</label>
          <div class="inline">
            <input id="offy" type="range" min="-128" max="128" value="0" />
            <span id="offyVal">0</span>
          </div>
        </div>
        <div class="row">
          <label for="animate">Translate Animation</label>
          <div class="inline">
            <input id="animate" type="checkbox" />
            <select id="dir">
              <option value="left">Shift Left</option>
              <option value="right">Shift Right</option>
            </select>
          </div>
        </div>
        <div class="row">
          <label for="speed">Speed</label>
          <div class="inline">
            <input id="speed" type="range" min="2" max="50" value="20" />
            <span id="speedVal">20 ms</span>
          </div>
        </div>
        <div class="row">
          <label for="interval">Loop Offset (px)</label>
          <div class="inline">
            <input id="interval" type="range" min="1" max="25" value="5" />
            <span id="intervalVal">5 px</span>
          </div>
        </div>
        <div class="btns">
          <button id="btnTextPreview">Preview Text</button>
          <button id="btn">Render & Upload</button>
          <button id="center">Center Text</button>
        </div>
        </div> <!-- end #textConfig -->
        <div id="themeConfig" style="display:none;">
          <div class="row">
            <label for="themeFile">Upload Theme</label>
            <input id="themeFile" type="file" accept=".html" />
          </div>
          <div class="btns">
            <button id="btnThemeUpload">Preview</button>
            <button id="btnThemeStart">Start</button>
          </div>
          <!-- Preview uses the main preview canvas above -->
          <div class="row">
            <label>Themes</label>
            <div id="themeList" class="muted">No themes yet.</div>
          </div>
        </div>
        <div id="clockConfig" style="display:none">
          <div class="row">
            <label for="clockFormat">Clock Format</label>
            <div class="inline">
              <select id="clockFormat">
                <option value="24" selected>24-hour</option>
                <option value="12">12-hour</option>
              </select>
            </div>
          </div>
          <div class="row">
            <label for="clockSize">Clock Size</label>
            <div class="inline">
              <input id="clockSize" type="range" min="10" max="50" value="28" />
              <span id="clockSizeVal">28 px</span>
            </div>
          </div>
          <div class="row">
            <label for="clockColor">Clock Color</label>
            <input id="clockColor" type="color" value="#ffffff" />
          </div>
          <div class="row">
            <label for="clockAuto">Auto Update</label>
            <div class="inline">
              <input id="clockAuto" type="checkbox" />
              <span class="muted">Interval</span>
              <select id="clockInterval">
                <option value="1">1s</option>
                <option value="5" selected>5s</option>
                <option value="10">10s</option>
                <option value="30">30s</option>
                <option value="60">60s</option>
              </select>
            </div>
          </div>
          <div class="btns">
            <button id="btnClockPreview">Preview Clock</button>
            <button id="btnClock">Start Clock</button>
          </div>
        </div> <!-- end #clockConfig -->
        <div id="videoConfig" style="display:none">
          <div class="row">
            <label for="videoFile">Video</label>
            <div class="inline">
              <input id="videoFile" type="file" accept="video/*" />
            </div>
          </div>
          <div class="row" id="videoFitRow">
            <label for="videoFit">Fit</label>
            <div class="inline">
              <select id="videoFit">
                <option value="fill">Fill Panel</option>
                <option value="fit" selected>Fit Inside</option>
                <option value="original">Original Size</option>
              </select>
              <span class="muted">FPS</span>
              <select id="videoFps">
                <option value="5">5</option>
                <option value="10" selected>10</option>
                <option value="15">15</option>
                <option value="20">20</option>
              </select>
              <label class="muted" for="videoLoop" style="display:inline-flex; align-items:center; gap:6px;">
                <input id="videoLoop" type="checkbox" checked /> Loop
              </label>
            </div>
          </div>
          <div class="btns">
            <button id="btnVideoStart">Start Video Upload</button>
            <button id="btnVideoStop">Stop Video Upload</button>
          </div>
        </div> <!-- end #videoConfig -->
      </div>
      <footer></footer>
      </div>
      <!-- Panel Configuration Overlay -->
      <div id="panelConfigPage" style="display:none; position:fixed; left:0; right:0; top:var(--header-h); bottom:0; background: rgba(11,15,20,0.96); z-index:30;">
        <div style="max-width:820px; margin:16px auto; padding:16px; border:1px solid #1f2a35; background:#121820;">
          <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
            <h2 style="margin:0; font-size:16px; color:var(--fg);">Panel Configuration</h2>
            <button id="btnPanelClose" class="icon-btn">✖️</button>
          </div>
          <div class="row">
            <label>Layout</label>
            <div class="inline" style="gap:16px; flex-wrap:wrap;">
              <label class="muted" style="display:inline-flex; align-items:center; gap:6px;">
                <input type="radio" name="panelLayout" id="layout1x1" value="1x1" checked /> 1 row × 1 column
              </label>
            </div>
          </div>
          <div class="btns">
            <button id="btnPanelApply">Apply</button>
            <button id="btnPanelCancel" class="icon-btn">Cancel</button>
          </div>
        </div>
      </div>
    </main>

    <script>
      // API base: when running locally via localhost, point to ESP32 AP.
      const apiBase = (location.hostname === '127.0.0.1' || location.hostname === 'localhost') ? 'http://192.168.4.1' : '';

      // Global variables
      const $ = id => document.getElementById(id);
      const c = document.getElementById('preview');
      const ctx = c.getContext('2d');
      let loadedImg = null;
      let userFontLoaded = false;

      // Animation state variables
      let rafId = 0; let lastTs = 0; let accMs = 0; let head0 = 0; let head1 = 0; let spacing = 0; let textW = 0; let textH = 0;
      let clockPreviewTimer = 0;
      let clockTimer = 0;
      let videoEl = null;
      let videoPreviewRaf = 0;
      let videoUploadActive = false;
      let videoUploadLastMs = 0;
      let videoUploadIntervalMs = 100;
      let videoUploadInFlight = false;

      // Stop all running content (comprehensive cleanup)
      function stopAllRunningContent() {
        // Stop text animation
        stopPreviewAnim();

        // Stop clock preview but keep LED timer running
        stopClockPreview();

        // Stop clock LED timer (only when explicitly stopping all content)
        if (clockTimer) {
          clearInterval(clockTimer);
          clockTimer = 0;
        }

        // Stop video
        stopVideoPreview();
        videoUploadActive = false;
        videoUploadInFlight = false;

        // Stop theme
        stopThemeTimers();
      }

      // Stop content for preview only (keep LED running)
      function stopContentForPreview() {
        // Stop text animation
        stopPreviewAnim();

        // Stop clock preview only (keep LED timer running)
        stopClockPreview();

        // Stop video preview and upload
        stopVideoPreview();
        videoUploadActive = false;
        videoUploadInFlight = false;

        // Stop theme preview (keep LED running)
        if (window.__themeTimer) {
          clearInterval(window.__themeTimer);
          window.__themeTimer = null;
        }
        // Don't clear __theme or stop __playTimer for preview mode
      }

      // Stop theme timers when switching away from theme tab
      function stopThemeTimers() {
        if (window.__themeTimer) {
          clearInterval(window.__themeTimer);
          window.__themeTimer = null;
        }
        if (window.__playTimer) {
          clearInterval(window.__playTimer);
          window.__playTimer = null;
        }
        // Also clear the theme object to prevent re-use
        window.__theme = null;
      }

      // Stop preview animation
      function stopPreviewAnim() {
        if (rafId) {
          cancelAnimationFrame(rafId);
          rafId = 0;
        }
        // Don't stop clock timer here - clock should continue running on LED panel
      }

      function getPreviewCanvas(){
        var pv = document.getElementById('preview');
        if(!pv){
          var holder = document.getElementById('previewInner') || document.body;
          pv = document.createElement('canvas');
          pv.id='preview'; pv.width=128; pv.height=64; pv.style.background='#000';
          pv.style.border='1px solid #243241'; holder.appendChild(pv);
        }
        return pv;
      }

      function rgb565(r,g,b){return ((r&0xF8)<<8)|((g&0xFC)<<3)|((b)>>3);} // 16-bit

      function cropImageData(img,w,h){
        let minX=w, minY=h, maxX=-1, maxY=-1;
        for(let y=0;y<h;y++){
          for(let x=0;x<w;x++){
            const a=img[(y*w+x)*4+3];
            if(a){ if(x<minX)minX=x; if(x>maxX)maxX=x; if(y<minY)minY=y; if(y>maxY)maxY=y; }
          }
        }
        if(maxX<minX||maxY<minY){return {x:0,y:0,w:0,h:0}};
        return {x:minX,y:minY,w:maxX-minX+1,h:maxY-minY+1};
      }

      function getFontFamily() {
        const useUploaded = (document.getElementById('fontUploaded') && document.getElementById('fontUploaded').checked);
        if (useUploaded && userFontLoaded) return `'UserFont', system-ui, Arial, sans-serif`;
        return `'Noto Sans Khmer', 'Khmer OS Content', system-ui, Arial, sans-serif`;
      }

      // Initialize preview animation
      function initPreviewAnim() {
        const pw=parseInt($('pw').value,10); const ph=parseInt($('ph').value,10);
        const size=parseInt($('fontSize').value,10);
        const text=$('text').value;
        const fam = getFontFamily();
        const font = `bold ${size}px ${fam}`;

        // measure text width (approx, includes padding if enabled)
        ctx.font=font; ctx.textBaseline='middle'; ctx.textAlign='left';
        const m = ctx.measureText(text);
        const pad = $('textBg').checked ? (parseInt($('textBgPad').value,10) || 0) : 0;
        textW = Math.ceil(m.width) + pad*2;
        textH = Math.ceil(size*1.2) + pad*2;
        const gap = parseInt($('interval').value,10) || 1;
        spacing = Math.max(1, textW + gap);

        if ($('dir').value === 'left') {
          head0 = pw; head1 = head0 + spacing;
        } else {
          head0 = -textW; head1 = head0 - spacing;
        }
        lastTs = 0; accMs = 0;
      }

      // Draw preview frame
      function drawPreviewFrame(animated){
        const text=$('text').value;
        const fam = getFontFamily();
        const size=parseInt($('fontSize').value,10);
        const font = `bold ${size}px ${fam}`;
        const color=$('color').value;
        const bg=$('bg').value;
        const pw=parseInt($('pw').value,10); const ph=parseInt($('ph').value,10);
        const offx=parseInt($('offx').value,10); const offy=parseInt($('offy').value,10);

        c.width = pw; c.height = ph;
        ctx.clearRect(0,0,c.width,c.height);
        ctx.fillStyle=bg; ctx.fillRect(0,0,c.width,c.height);

        if ($('bgMode').value === 'image' && loadedImg) {
          const fit = $('imageFit').value;
          let dw = loadedImg.width, dh = loadedImg.height;
          if (fit === 'fill') { dw = pw; dh = ph; }
          else if (fit === 'fit') {
            const s = Math.min(pw/loadedImg.width, ph/loadedImg.height);
            dw = Math.max(1, Math.floor(loadedImg.width * s));
            dh = Math.max(1, Math.floor(loadedImg.height * s));
          } else if (fit === 'original') {
            dw = Math.min(pw, loadedImg.width); dh = Math.min(ph, loadedImg.height);
          }
          const dx = Math.floor(pw*0.5 - dw/2);
          const dy = Math.floor(ph*0.5 - dh/2);
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(loadedImg, dx, dy, dw, dh);
        }

        // text background box (optional) and text overlay
        const cy = Math.floor(ph*0.5) + offy;
        const pad = $('textBg').checked ? (parseInt($('textBgPad').value,10) || 0) : 0;
        ctx.font=font; ctx.textBaseline='middle'; ctx.fillStyle=color;

        if (animated && text.length > 0) {
          // draw two heads for seamless wrap
          ctx.textAlign='left';
          const drawAt = (leftX) => {
            const xLeft = Math.floor(leftX) + offx;
            if ($('textBg').checked){
              ctx.fillStyle = $('textBgColor').value;
              if ($('textBgRound').checked) {
                const r = parseInt($('textBgRadius').value,10) || 0;
                const rr = Math.max(0, Math.min(r, Math.min(textW,textH)/2));
                ctx.beginPath();
                const rx = xLeft - pad, ry = cy - Math.floor(textH/2);
                const rw = textW, rh = textH;
                ctx.moveTo(rx+rr, ry);
                ctx.arcTo(rx+rw, ry,   rx+rw, ry+rh, rr);
                ctx.arcTo(rx+rw, ry+rh, rx,     ry+rh, rr);
                ctx.arcTo(rx,     ry+rh, rx,     ry,     rr);
                ctx.arcTo(rx,     ry,   rx+rw,   ry,     rr);
                ctx.closePath();
                ctx.fill();
              } else {
                ctx.fillRect(xLeft - pad, cy - Math.floor(textH/2), textW, textH);
              }
              ctx.fillStyle = color;
            }
            ctx.fillText(text, xLeft, cy);
          };
          drawAt(head0);
          drawAt(head1);
        } else {
          // static centered
          const cx = Math.floor(pw*0.5) + offx;
          ctx.textAlign='center';
          if ($('textBg').checked){
            const m = ctx.measureText(text);
            const tw = Math.ceil(m.width) + pad*2;
            const th = Math.ceil(size*1.2) + pad*2;
            ctx.fillStyle = $('textBgColor').value;
            if ($('textBgRound').checked) {
              const r = parseInt($('textBgRadius').value,10) || 0;
              const rr = Math.max(0, Math.min(r, Math.min(tw,th)/2));
              const rx = cx - Math.floor(tw/2), ry = cy - Math.floor(th/2);
              ctx.beginPath();
              ctx.moveTo(rx+rr, ry);
              ctx.arcTo(rx+tw, ry,   rx+tw, ry+th, rr);
              ctx.arcTo(rx+tw, ry+th, rx,    ry+th, rr);
              ctx.arcTo(rx,    ry+th, rx,    ry,    rr);
              ctx.arcTo(rx,    ry,   rx+tw,  ry,    rr);
              ctx.closePath();
              ctx.fill();
            } else {
              ctx.fillRect(cx - Math.floor(tw/2), cy - Math.floor(th/2), tw, th);
            }
            ctx.fillStyle = color;
          }
          ctx.fillText(text, cx, cy);
        }
      }

      // Animate preview
      function animatePreview(ts){
        if (!$('animate').checked || $('text').value.trim().length === 0) {
          stopPreviewAnim();
          drawPreviewFrame(false);
          return;
        }

        if (!lastTs) lastTs = ts;
        const speed = parseInt($('speed').value,10) || 30;
        accMs += (ts - lastTs); lastTs = ts;

        while (accMs >= speed) {
          accMs -= speed;
          if ($('dir').value === 'left') { head0 -= 1; head1 -= 1; }
          else { head0 += 1; head1 += 1; }
          const pw = parseInt($('pw').value,10);
          // recycle heads
          if ($('dir').value === 'left') {
            if (head0 + textW <= 0) head0 = head1 + spacing;
            if (head1 + textW <= 0) head1 = head0 + spacing;
          } else {
            if (head0 >= pw) head0 = head1 - spacing;
            if (head1 >= pw) head1 = head0 - spacing;
          }
        }
        drawPreviewFrame(true);
        rafId = requestAnimationFrame(animatePreview);
      }

      // Clock functions
      function formatTime(fmt){
        const d = new Date();
        let h = d.getHours(); let m = d.getMinutes(); let s = d.getSeconds();
        if (fmt==='12') { const ampm = h>=12?'PM':'AM'; h = h%12 || 12; return `${(''+h).padStart(2,'0')}:${(''+m).padStart(2,'0')}:${(''+s).padStart(2,'0')} ${ampm}`; }
        return `${(''+h).padStart(2,'0')}:${(''+m).padStart(2,'0')}:${(''+s).padStart(2,'0')}`;
      }

      function drawClockPreviewFrame(){
        const pw=parseInt($('pw').value,10); const ph=parseInt($('ph').value,10);
        const offx=parseInt($('offx').value,10); const offy=parseInt($('offy').value,10);
        const fmt = $('clockFormat').value;
        const size = parseInt($('clockSize').value,10);
        const fam = getFontFamily(); const font = `bold ${size}px ${fam}`;
        const col = $('clockColor').value;
        const bg = $('bg').value;
        c.width = pw; c.height = ph;
        ctx.clearRect(0,0,c.width,c.height);
        // draw background (respect image mode)
        ctx.fillStyle = bg; ctx.fillRect(0,0,pw,ph);
        if ($('bgMode').value === 'image' && loadedImg) {
          const fit = $('imageFit').value;
          let dw = loadedImg.width, dh = loadedImg.height;
          if (fit === 'fill') { dw = pw; dh = ph; }
          else if (fit === 'fit') {
            const s = Math.min(pw/loadedImg.width, ph/loadedImg.height);
            dw = Math.max(1, Math.floor(loadedImg.width * s));
            dh = Math.max(1, Math.floor(loadedImg.height * s));
          } else if (fit === 'original') {
            dw = Math.min(pw, loadedImg.width); dh = Math.min(ph, loadedImg.height);
          }
          const dx = Math.floor(pw*0.5 - dw/2);
          const dy = Math.floor(ph*0.5 - dh/2);
          ctx.imageSmoothingEnabled = false;
          ctx.drawImage(loadedImg, dx, dy, dw, dh);
        }
        // draw time centered
        ctx.font = font; ctx.textBaseline='middle'; ctx.textAlign='center'; ctx.fillStyle=col;
        const txt = formatTime(fmt);
        ctx.fillText(txt, Math.floor(pw*0.5)+offx, Math.floor(ph*0.5)+offy);
      }

      function startClockPreview(){
        if (clockPreviewTimer) clearInterval(clockPreviewTimer);
        drawClockPreviewFrame();
        clockPreviewTimer = setInterval(drawClockPreviewFrame, 1000);
      }

      function stopClockPreview(){
        if (clockPreviewTimer) {
          clearInterval(clockPreviewTimer);
          clockPreviewTimer=0;
        }
      }

      async function renderAndUploadClock(){
        // Stop all other modes when starting clock render
        stopAllRunningContent();

        const pw=parseInt($('pw').value,10); const ph=parseInt($('ph').value,10);
        const offx=parseInt($('offx').value,10); const offy=parseInt($('offy').value,10);
        const fmt = $('clockFormat').value;
        const size = parseInt($('clockSize').value,10);
        const fam = getFontFamily(); const font = `bold ${size}px ${fam}`;
        const col = $('clockColor').value;
        const bg = $('bg').value;
        const t = document.createElement('canvas'); t.width = pw; t.height = ph; const tctx=t.getContext('2d');
        tctx.fillStyle=bg; tctx.fillRect(0,0,pw,ph);
        tctx.font=font; tctx.textBaseline='middle'; tctx.textAlign='center'; tctx.fillStyle=col;
        const txt = formatTime(fmt);
        tctx.fillText(txt, Math.floor(pw*0.5)+offx, Math.floor(ph*0.5)+offy);
        const out = tctx.getImageData(0,0,pw,ph);
        const buf = new Uint8Array(4 + pw*ph*2);
        buf[0]=pw&255; buf[1]=(pw>>8)&255; buf[2]=ph&255; buf[3]=(ph>>8)&255;
        let p=4; const d=out.data;
        for(let y=0;y<ph;y++){
          for(let x=0;x<pw;x++){
            const i=(y*pw+x)*4; const r=d[i], g=d[i+1], b=d[i+2];
            const v=((r&0xF8)<<8)|((g&0xFC)<<3)|((b)>>3);
            buf[p++]=v&255; buf[p++]=(v>>8)&255;
          }
        }
        const fd = new FormData();
        fd.append('image', new Blob([buf], {type:'application/octet-stream'}), 'clock.rgb565');
        fd.append('bg', bg);
        fd.append('bgMode', 'color');
        fd.append('offx', 0);
        fd.append('offy', 0);
        fd.append('animate', 0);
        fd.append('dir', 'left');
        fd.append('speed', 20);
        fd.append('interval', 5);
        await fetch(apiBase + '/upload', { method:'POST', body: fd });
      }

      // Video functions
      function drawVideoPreviewFrame(){
        if (!videoEl) return;
        const pw=parseInt($('pw').value,10); const ph=parseInt($('ph').value,10);
        const bg = $('bg').value;
        c.width = pw; c.height = ph;
        ctx.clearRect(0,0,c.width,c.height);
        ctx.fillStyle = bg; ctx.fillRect(0,0,pw,ph);
        // draw video frame with fit
        const fit = document.getElementById('videoFit') ? document.getElementById('videoFit').value : 'fit';
        let dw = videoEl.videoWidth || pw, dh = videoEl.videoHeight || ph;
        if (fit === 'fill') { dw = pw; dh = ph; }
        else if (fit === 'fit') {
          const s = Math.min(pw/(dw||1), ph/(dh||1)); dw = Math.max(1, Math.floor(dw*s)); dh = Math.max(1, Math.floor(dh*s));
        } else { // original
          dw = Math.min(pw, dw); dh = Math.min(ph, dh);
        }
        const dx = Math.floor(pw*0.5 - dw/2);
        const dy = Math.floor(ph*0.5 - dh/2);
        try { ctx.drawImage(videoEl, dx, dy, dw, dh); } catch(_){}
      }

      function videoPreviewLoop(ts){
        drawVideoPreviewFrame();
        // streaming upload synced with preview FPS
        if (videoUploadActive && !videoUploadInFlight) {
          if (!videoUploadLastMs) videoUploadLastMs = ts || performance.now();
          const now = ts || performance.now();
          if (now - videoUploadLastMs >= videoUploadIntervalMs) {
            videoUploadLastMs = now;
            // fire and forget upload of current frame
            uploadVideoFrame(true);
          }
        }
        videoPreviewRaf = requestAnimationFrame(videoPreviewLoop);
      }

      function startVideoPreview(){
        if (!videoEl || videoEl.readyState < 2) return; // not enough data
        if (videoPreviewRaf) cancelAnimationFrame(videoPreviewRaf);
        videoPreviewRaf = requestAnimationFrame(videoPreviewLoop);
      }

      function stopVideoPreview(){
        if (videoPreviewRaf) {
          cancelAnimationFrame(videoPreviewRaf);
          videoPreviewRaf=0;
        }
      }

      async function uploadVideoFrame(nonBlocking){
        if (!videoEl) return;
        const pw=parseInt($('pw').value,10); const ph=parseInt($('ph').value,10);
        const t = document.createElement('canvas'); t.width = pw; t.height = ph; const tctx=t.getContext('2d');
        // background
        const bg = $('bg').value; tctx.fillStyle=bg; tctx.fillRect(0,0,pw,ph);
        // draw current video frame same as preview
        const fit = document.getElementById('videoFit') ? document.getElementById('videoFit').value : 'fit';
        let dw = videoEl.videoWidth || pw, dh = videoEl.videoHeight || ph;
        if (fit === 'fill') { dw = pw; dh = ph; }
        else if (fit === 'fit') {
          const s = Math.min(pw/(dw||1), ph/(dh||1)); dw = Math.max(1, Math.floor(dw*s)); dh = Math.max(1, Math.floor(dh*s));
        } else { dw = Math.min(pw, dw); dh = Math.min(ph, dh); }
        const dx = Math.floor(pw*0.5 - dw/2);
        const dy = Math.floor(ph*0.5 - dh/2);
        try { tctx.drawImage(videoEl, dx, dy, dw, dh); } catch(_){ return; }
        const out = tctx.getImageData(0,0,pw,ph);
        const buf = new Uint8Array(4 + pw*ph*2);
        buf[0]=pw&255; buf[1]=(pw>>8)&255; buf[2]=ph&255; buf[3]=(ph>>8)&255;
        let p=4; const d=out.data;
        for(let y=0;y<ph;y++){
          for(let x=0;x<pw;x++){
            const i=(y*pw+x)*4; const r=d[i], g=d[i+1], b=d[i+2];
            const v=((r&0xF8)<<8)|((g&0xFC)<<3)|((b)>>3);
            buf[p++]=v&255; buf[p++]=(v>>8)&255;
          }
        }
        const fd = new FormData();
        fd.append('image', new Blob([buf], {type:'application/octet-stream'}), 'video.rgb565');
        fd.append('bg', bg);
        fd.append('bgMode', 'color');
        fd.append('offx', 0);
        fd.append('offy', 0);
        fd.append('animate', 0);
        fd.append('dir', 'left');
        fd.append('speed', 20);
        fd.append('interval', 5);
        try {
          if (nonBlocking) {
            videoUploadInFlight = true;
            fetch(apiBase + '/upload', { method:'POST', body: fd }).finally(()=>{ videoUploadInFlight = false; });
          } else {
            await fetch(apiBase + '/upload', { method:'POST', body: fd });
          }
        } catch(_){ videoUploadInFlight = false; }
      }

      // Main draw function
      function drawPreview(){
        const clockMode = (document.getElementById('clockConfig') && document.getElementById('clockConfig').style.display !== 'none');
        const videoMode = (document.getElementById('videoConfig') && document.getElementById('videoConfig').style.display !== 'none');
        const textMode = (document.getElementById('textConfig') && document.getElementById('textConfig').style.display !== 'none');

        if (videoMode) {
          stopPreviewAnim(); drawVideoPreviewFrame();
        } else if (clockMode) {
          stopPreviewAnim(); drawClockPreviewFrame();
        } else if (textMode && $('animate').checked && $('text').value.trim().length > 0) {
          stopPreviewAnim(); initPreviewAnim(); drawPreviewFrame(true); rafId = requestAnimationFrame(animatePreview);
        } else {
          stopPreviewAnim(); drawPreviewFrame(false);
        }
      }

      // Tab switching - keep running until new action is started
      function initTabs(){
        const tabText = document.getElementById('tabText');
        const tabClock = document.getElementById('tabClock');
        const tabVideo = document.getElementById('tabVideo');
        const tabTheme = document.getElementById('tabTheme');
        const textCfg = document.getElementById('textConfig');
        const clockCfg = document.getElementById('clockConfig');
        const videoCfg = document.getElementById('videoConfig');
        const themeCfg = document.getElementById('themeConfig');

        function activate(which){
          if (which==='text'){
            tabText.classList.add('active'); tabClock.classList.remove('active'); if (tabVideo) tabVideo.classList.remove('active'); if (tabTheme) tabTheme.classList.remove('active');
            textCfg.style.display='block'; clockCfg.style.display='none'; if (videoCfg) videoCfg.style.display='none'; if (themeCfg) themeCfg.style.display='none';
            // Don't stop anything automatically - let user decide when to start/stop
          } else if (which==='clock') {
            tabClock.classList.add('active'); tabText.classList.remove('active'); if (tabVideo) tabVideo.classList.remove('active'); if (tabTheme) tabTheme.classList.remove('active');
            clockCfg.style.display='block'; textCfg.style.display='none'; if (videoCfg) videoCfg.style.display='none'; if (themeCfg) themeCfg.style.display='none';
            // Don't stop anything automatically - let user decide when to start/stop
          } else if (which==='video') {
            if (tabVideo) tabVideo.classList.add('active'); tabText.classList.remove('active'); tabClock.classList.remove('active'); if (tabTheme) tabTheme.classList.remove('active');
            if (videoCfg) videoCfg.style.display='block'; textCfg.style.display='none'; clockCfg.style.display='none'; if (themeCfg) themeCfg.style.display='none';
            // Don't stop anything automatically - let user decide when to start/stop
          } else if (which==='theme') {
            if (tabTheme) tabTheme.classList.add('active'); if (tabVideo) tabVideo.classList.remove('active'); tabText.classList.remove('active'); tabClock.classList.remove('active');
            if (themeCfg) themeCfg.style.display='block';
            textCfg.style.display='none'; if (videoCfg) videoCfg.style.display='none'; clockCfg.style.display='none';
            // Don't stop anything automatically - let user decide when to start/stop
          }
          // Don't drawPreview() on tab switch - keep current state
        }

        if (tabText) tabText.addEventListener('click', ()=>activate('text'));
        if (tabClock) tabClock.addEventListener('click', ()=>activate('clock'));
        if (tabVideo) tabVideo.addEventListener('click', ()=>activate('video'));
        if (tabTheme) tabTheme.addEventListener('click', ()=>activate('theme'));

        // Theme functionality
        const btnThemeUpload = document.getElementById('btnThemeUpload');
        const btnThemeStart  = document.getElementById('btnThemeStart');
        if (btnThemeUpload) btnThemeUpload.addEventListener('click', async ()=>{
          const inp = document.getElementById('themeFile');
          const f = inp && inp.files && inp.files[0];
          if(!f){ alert('Choose a theme HTML file first'); return; }
          const txt = await f.text();
          const m = txt.match(/<fps>\s*(\d{1,2})\s*<\/fps>/i);
          const currentThemeFps = m ? Math.max(1, Math.min(30, parseInt(m[1],10)||1)) : 1;
          try{
            const mscript = txt.match(/<script[^>]*>([\s\S]*?)<\/script>/i);
            if(!mscript) throw new Error('No <script> in theme');
            const code = mscript[1];
            const api = Function(`${code}; return {init: (typeof themeInit!=='undefined'?themeInit:null), render: (typeof themeRender!=='undefined'?themeRender:null)};`)();
            if(!api || !api.render){ throw new Error('themeRender() not found'); }
            window.__theme = api;
            const pv = getPreviewCanvas();
            const pctx = pv.getContext('2d');
            const state = api.init ? api.init() : {};
            if(window.__themeTimer) clearInterval(window.__themeTimer);
            const step=()=>{ pctx.clearRect(0,0,pv.width,pv.height); api.render(pctx, pv.width, pv.height, state, Date.now()); };
            const period = Math.round(1000/Math.max(1, Math.min(30,currentThemeFps)));
            window.__themeTimer=setInterval(step, period);
            step();
            // Stop other modes when previewing theme
            stopAllRunningContent();
          }catch(e){ alert('Theme error: '+e.message); }
          try{
            const fd = new FormData(); fd.append('file', f, f.name);
            await fetch(apiBase + '/upload_theme',{method:'POST', body:fd});
          }catch(_){ /* ignore */ }
        });
        if (btnThemeStart) btnThemeStart.addEventListener('click', async ()=>{
          const pv = getPreviewCanvas();
          const pctx = pv.getContext('2d');
          if(!window.__theme || !window.__theme.render){ alert('Upload a theme first'); return; }

          // Stop all other modes when starting theme playback
          stopAllRunningContent();

          const api = window.__theme;
          const state = api.init ? api.init() : {};
          if(window.__playTimer) clearInterval(window.__playTimer);
          const step=async()=>{
            api.render(pctx, pv.width, pv.height, state, Date.now());
            // Pack RGB565 and POST to device
            const img=pctx.getImageData(0,0,pv.width,pv.height);
            const w=pv.width,h=pv.height; const d=img.data; const buf=new Uint8Array(4+w*h*2);
            buf[0]=w&255; buf[1]=w>>8; buf[2]=h&255; buf[3]=h>>8; let i=4;
            for(let k=0;k<d.length;k+=4){ const r=d[k],g=d[k+1],b=d[k+2]; const v=((r&0xF8)<<8)|((g&0xFC)<<3)|(b>>>3); buf[i++]=v&255; buf[i++]=v>>8; }
            const fd=new FormData(); fd.append('image', new Blob([buf],{type:'application/octet-stream'}),'frame.rgb565');
            try{ await fetch(apiBase + '/upload',{method:'POST', body:fd}); }catch(_){ }
          };
          window.__playTimer=setInterval(step, 1000);
          step();
        });
      }

      // Panel configuration
      async function openPanelConfig(){
        const page = document.getElementById('panelConfigPage');
        if (!page) return;
        // Fetch current layout and set radios
        try {
          const r = await fetch(apiBase + '/panel_info', { cache:'no-store' });
          if (r.ok) {
            const j = await r.json();
            const rows = (j.layout && j.layout.rows) ? j.layout.rows : j.rows;
            const cols = (j.layout && j.layout.cols) ? j.layout.cols : j.cols;
            const a = document.getElementById('layout1x1');
            if (a) a.checked = true;
          }
        } catch(_){
          const a = document.getElementById('layout1x1');
          if (a) a.checked = true;
        }
        page.style.display='block';
      }

      function closePanelConfig(){
        const page = document.getElementById('panelConfigPage');
        if (page) page.style.display='none';
      }

      function initPanelConfig() {
        const btnPC = document.getElementById('btnPanelConfig');
        const btnPCClose = document.getElementById('btnPanelClose');
        const btnPCApply = document.getElementById('btnPanelApply');
        const btnPCCancel = document.getElementById('btnPanelCancel');
        if (btnPC) btnPC.addEventListener('click', openPanelConfig);
        if (btnPCClose) btnPCClose.addEventListener('click', closePanelConfig);
        if (btnPCCancel) btnPCCancel.addEventListener('click', closePanelConfig);
        if (btnPCApply) btnPCApply.addEventListener('click', async ()=>{
          const body = new URLSearchParams(); body.set('layout', '1x1');
          try { await fetch(apiBase + '/panel_layout', { method:'POST', body }); } catch(_){ }
          closePanelConfig();
        });
      }

      // Event listeners
      function initEventListeners() {
        // Main render button
        const mainBtn = $('btn');
        if (mainBtn) {
          mainBtn.addEventListener('click', async function(e) {
            e.preventDefault();
            await renderAndUpload();
          });
        }

        // Center button
        const centerBtn = $('center');
        if (centerBtn) {
          centerBtn.addEventListener('click', function(e) {
            e.preventDefault();
            $('offx').value=0; $('offy').value=0;
            $('offxVal').textContent='0'; $('offyVal').textContent='0';
            drawPreview();
          });
        }

        // Text and configuration inputs
        ['text','fontSize','color','bg','pw','ph','offx','offy','animate','dir','speed','interval','textBgRound','textBgRadius','brightness'].forEach(id=> {
          $(id).addEventListener('input', ()=>{
            if(id==='fontSize'){ $('fontSizeVal').textContent = $('fontSize').value + ' px'; }
            if(id==='speed'){ $('speedVal').textContent = $('speed').value + ' ms'; }
            if(id==='interval'){ $('intervalVal').textContent = $('interval').value + ' px'; }
            if(id==='brightness'){ $('brightnessVal').textContent = $('brightness').value + '%'; }
            drawPreview();
          });
        });

        // Select inputs for mobile
        ['pw','ph'].forEach(id=> $(id).addEventListener('change', drawPreview));

        // Image file upload
        $('imageFile').addEventListener('change', (e)=>{
          const f = e.target.files && e.target.files[0];
          if(!f) return;
          const img = new Image();
          img.onload = ()=>{ loadedImg = img; drawPreview(); };
          const url = URL.createObjectURL(f);
          img.src = url;
        });

        // Background mode change
        $('bgMode').addEventListener('change', ()=>{
          const mode = $('bgMode').value;
          const showImg = mode==='image';
          $('bg').style.display = showImg? 'none':'inline-block';
          $('imageFile').style.display = showImg? 'inline-block':'none';
          const fitRow = document.getElementById('imageFitRow');
          if (fitRow) fitRow.style.display = showImg? 'grid':'none';
          drawPreview();
        });

        // Image fit change
        $('imageFit').addEventListener('change', drawPreview);

        // Text background settings
        $('textBg').addEventListener('change', drawPreview);
        $('textBgColor').addEventListener('input', drawPreview);
        $('textBgPad').addEventListener('change', drawPreview);
        $('textBgRound').addEventListener('change', drawPreview);
        $('textBgRadius').addEventListener('change', drawPreview);

        // Offset display updates
        $('offx').addEventListener('input', ()=> $('offxVal').textContent=$('offx').value);
        $('offy').addEventListener('input', ()=> $('offyVal').textContent=$('offy').value);

        // Custom font upload
        document.getElementById('customFont').addEventListener('change', async (e)=>{
          const f = e.target.files && e.target.files[0];
          if (!f) return;
          try {
            const data = await f.arrayBuffer();
            const ff = new FontFace('UserFont', data);
            await ff.load();
            document.fonts.add(ff);
            userFontLoaded = true;
            await document.fonts.ready;
            // enable the Uploaded radio and select it by default
            const uploadedRadio = document.getElementById('fontUploaded');
            if (uploadedRadio) { uploadedRadio.disabled = false; uploadedRadio.checked = true; }
            drawPreview();
          } catch (err) {
            console.error('Custom font failed to load', err);
            alert('Custom font failed to load');
          }
        });

        // Font source changes
        const fontDefault = document.getElementById('fontDefault');
        const fontUploaded = document.getElementById('fontUploaded');
        if (fontDefault) fontDefault.addEventListener('change', drawPreview);
        if (fontUploaded) fontUploaded.addEventListener('change', drawPreview);

        // Text preview button
        const btnTextPreview = document.getElementById('btnTextPreview');
        if (btnTextPreview) btnTextPreview.addEventListener('click', function(e) {
          e.preventDefault();
          // Stop other content for preview only (keep LED running)
          stopContentForPreview();
          drawPreview();
        });

        // Clock preview button
        const btnClockPreview = document.getElementById('btnClockPreview');
        if (btnClockPreview) btnClockPreview.addEventListener('click', function(e) {
          e.preventDefault();
          // Stop other content for preview only (keep LED clock running)
          stopContentForPreview();
          drawClockPreviewFrame();
          // Start clock preview animation (update every second)
          if (clockPreviewTimer) clearInterval(clockPreviewTimer);
          clockPreviewTimer = setInterval(drawClockPreviewFrame, 1000);
        });

        // Clock start button
        const btnClock = document.getElementById('btnClock');
        if (btnClock) btnClock.addEventListener('click', async ()=>{
          await renderAndUploadClock();
          if ($('clockAuto').checked){
            if (clockTimer) clearInterval(clockTimer);
            const sec = parseInt($('clockInterval').value,10)||5;
            clockTimer = setInterval(renderAndUploadClock, sec*1000);
          } else {
            if (clockTimer) { clearInterval(clockTimer); clockTimer=0; }
          }
        });

        // Video events
        const btnVideoStart = document.getElementById('btnVideoStart');
        const btnVideoStop = document.getElementById('btnVideoStop');
        if (btnVideoStart) btnVideoStart.addEventListener('click', ()=>{
          // Stop all other modes when starting video
          stopAllRunningContent();

          const fpsSel = document.getElementById('videoFps');
          const fps = fpsSel ? parseInt(fpsSel.value,10) || 10 : 10;
          videoUploadIntervalMs = Math.max(50, Math.floor(1000/fps));
          videoUploadActive = true; videoUploadLastMs = 0;
          // ensure preview is running
          startVideoPreview();
        });
        if (btnVideoStop) btnVideoStop.addEventListener('click', ()=>{
          videoUploadActive = false;
          videoUploadInFlight=false;
        });

        // Video file load
        const vf = document.getElementById('videoFile');
        if (vf) {
          videoEl = document.createElement('video');
          videoEl.muted = true; videoEl.loop = true; videoEl.playsInline = true; videoEl.crossOrigin='anonymous';
          vf.addEventListener('change', async (e)=>{
            const f = e.target.files && e.target.files[0];
            if(!f) return;
            try {
              const url = URL.createObjectURL(f);
              videoEl.src = url;
              await videoEl.play();
              // if video tab active start preview
              const inVideo = (document.getElementById('videoConfig') && document.getElementById('videoConfig').style.display !== 'none');
              if (inVideo) startVideoPreview();
            } catch(err){ console.error('Video play failed', err); }
          });
        }

        // Video loop checkbox
        const loopCb = document.getElementById('videoLoop');
        if (loopCb) loopCb.addEventListener('change', ()=>{
          if (videoEl) videoEl.loop = loopCb.checked;
        });
      }

      // Render and upload function
      async function renderAndUpload(){
        // Stop all other modes when starting text render
        stopAllRunningContent();

        drawPreview();
        const pw=parseInt($('pw').value,10); const ph=parseInt($('ph').value,10);
        const animate=$('animate').checked; const dir=$('dir').value;
        const speed=parseInt($('speed').value,10);
        const interval=parseInt($('interval').value,10);
        const offx=parseInt($('offx').value,10); const offy=parseInt($('offy').value,10);

        let outCanvas = document.createElement('canvas');
        if ($('bgMode').value === 'image' && loadedImg) {
          // Build panel-sized background image
          outCanvas.width = pw; outCanvas.height = ph;
          let octx = outCanvas.getContext('2d'); octx.imageSmoothingEnabled=false;
          const fit = $('imageFit').value;
          let dw = loadedImg.width, dh = loadedImg.height;
          if (fit === 'fill') { dw = pw; dh = ph; }
          else if (fit === 'fit') {
            const s = Math.min(pw/loadedImg.width, ph/loadedImg.height);
            dw = Math.max(1, Math.floor(loadedImg.width * s));
            dh = Math.max(1, Math.floor(loadedImg.height * s));
          } else { // original
            dw = Math.min(pw, loadedImg.width); dh = Math.min(ph, loadedImg.height);
          }
          const dx = Math.floor(pw*0.5 - dw/2);
          const dy = Math.floor(ph*0.5 - dh/2);
          // fill with bg color first (areas outside image)
          octx.fillStyle = $('bg').value; octx.fillRect(0,0,pw,ph);
          octx.drawImage(loadedImg, dx, dy, dw, dh);
          // Upload background first
          const outBg = octx.getImageData(0,0,pw,ph);
          const bufBg = new Uint8Array(4 + pw*ph*2);
          bufBg[0]=pw&255; bufBg[1]=(pw>>8)&255; bufBg[2]=ph&255; bufBg[3]=(ph>>8)&255;
          let pb=4; const db=outBg.data;
          for(let y=0;y<ph;y++){
            for(let x=0;x<pw;x++){
              const i=(y*pw+x)*4; const r=db[i], g=db[i+1], b=db[i+2];
              const v=rgb565(r,g,b);
              bufBg[pb++]=v&255; bufBg[pb++]=(v>>8)&255;
            }
          }
          const fdBg = new FormData();
          fdBg.append('image', new Blob([bufBg], {type:'application/octet-stream'}), 'bg.rgb565');
          await fetch(apiBase + '/upload_bg', { method:'POST', body: fdBg });
        }
        // Now build text-only transparent canvas (or skip if no text)
        if ($('text').value.trim().length > 0) {
          // Build transparent text-only canvas
          const fam = getFontFamily(); const size=parseInt($('fontSize').value,10);
          const font = `bold ${size}px ${fam}`;
          let t = document.createElement('canvas'); let tctx = t.getContext('2d');
          tctx.font=font; tctx.textBaseline='alphabetic'; tctx.textAlign='left';
          const metrics = tctx.measureText($('text').value);
          let tw = Math.max(1, Math.ceil(metrics.width)+4);
          let th = Math.max(1, Math.ceil(size*1.2 + 6));
          t.width = tw; t.height = th;
          tctx.font=font; tctx.textBaseline='alphabetic'; tctx.textAlign='left';
          // optional text background box (opaque)
          if ($('textBg').checked) {
            const pad = parseInt($('textBgPad').value,10) || 0;
            t.width = tw + pad*2; t.height = th + pad*2;
            // redraw font after resize
            tctx = t.getContext('2d'); tctx.font=font; tctx.textBaseline='alphabetic'; tctx.textAlign='left';
            tctx.fillStyle = $('textBgColor').value;
            if ($('textBgRound').checked) {
              const r = parseInt($('textBgRadius').value,10) || 0;
              const rr = Math.max(0, Math.min(r, Math.min(t.width,t.height)/2));
              tctx.beginPath();
              tctx.moveTo(rr, 0);
              tctx.arcTo(t.width, 0,   t.width, t.height, rr);
              tctx.arcTo(t.width, t.height, 0,   t.height, rr);
              tctx.arcTo(0,   t.height, 0,   0,   rr);
              tctx.arcTo(0,   0,   t.width, 0,   rr);
              tctx.closePath();
              tctx.fill();
            } else {
              tctx.fillRect(0, 0, t.width, t.height);
            }
          }
          tctx.fillStyle=$('color').value;
          const baseY = Math.floor(size);
          tctx.fillText($('text').value, 0, baseY);
          const img = tctx.getImageData(0,0,t.width,t.height);
          const bb = cropImageData(img.data, t.width, t.height);
          let outW = Math.max(1, bb.w), outH = Math.max(1, bb.h);
          outCanvas.width = outW; outCanvas.height = outH;
          outCanvas.getContext('2d').putImageData(new ImageData(img.data, t.width, t.height), -bb.x, -bb.y);
        } else {
          outCanvas.width = 1; outCanvas.height = 1; // minimal placeholder
        }

        // pack A8 + RGB565 (LE) per pixel with header [w,h]
        const out = outCanvas.getContext('2d').getImageData(0,0,outCanvas.width,outCanvas.height);
        const outW = outCanvas.width, outH = outCanvas.height;
        const buf = new Uint8Array(4 + outW*outH*3);
        buf[0]=outW&255; buf[1]=(outW>>8)&255; buf[2]=outH&255; buf[3]=(outH>>8)&255;
        let p=4; const d=out.data;
        for(let y=0;y<outH;y++){
          for(let x=0;x<outW;x++){
            const i=(y*outW+x)*4; const r=d[i], g=d[i+1], b=d[i+2], a=d[i+3];
            const v=rgb565(r,g,b);
            buf[p++]=a; buf[p++]=v&255; buf[p++]=(v>>8)&255;
          }
        }
        const fd = new FormData();
        fd.append('image', new Blob([buf], {type:'application/octet-stream'}), 'img.rgb565');
        fd.append('bg', $('bg').value);
        fd.append('bgMode', $('bgMode').value);
        fd.append('offx', offx);
        fd.append('offy', offy);
        fd.append('animate', ( $('text').value.trim().length>0 && animate)?1:0);
        fd.append('brightness', parseInt($('brightness').value, 10));
        fd.append('dir', dir);
        fd.append('speed', speed);
        fd.append('interval', interval);
        const res = await fetch(apiBase + '/upload', { method:'POST', body: fd });
        if(!res.ok){ alert('Upload failed: '+res.status); return; }
      }

      // Initialize everything
      function initApp() {
        // Initialize display values
        $('brightnessVal').textContent = $('brightness').value + '%';
        $('fontSizeVal').textContent = $('fontSize').value + ' px';
        $('speedVal').textContent = $('speed').value + ' ms';
        $('intervalVal').textContent = $('interval').value + ' px';
        $('offxVal').textContent = $('offx').value;
        $('offyVal').textContent = $('offy').value;

        // Initialize background mode display
        (function(){
          const showImg = $('bgMode').value==='image';
          const fitRow = document.getElementById('imageFitRow');
          if (fitRow) fitRow.style.display = showImg? 'grid':'none';
        })();

        // Initialize all components
        initTabs();
        initEventListeners();
        initPanelConfig();

        // Initial preview
        drawPreview();
      }

      // Start the application
      document.addEventListener('DOMContentLoaded', initApp);
    </script>
  </body>
</html>